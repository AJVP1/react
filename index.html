<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="styles.css" />
    <title>React</title>
  </head>
  <body>
    <!-- navegacion -->
    <nav>
      <h2>Indice</h2>
      <ul>
        <li><a href="#introduccion">Introducción</a></li>
        <li>
          <a href="#empezar-un-proyecto">Empezar un proyecto</a>
          <ul>
            <li>
              <a href="#tailwind-en-react-con-vite"
                >Tailwind en react con vite</a
              >
            </li>
          </ul>
        </li>
        <li>
          <a href="#componentes">Componentes</a>
          <ul>
            <li><a href="#props">Props</a></li>
            <li><a href="#estados-usestate">Estados (useState)</a></li>
            <li>
              <a href="#efectos-secundarios-useeffect"
                >Efectos secundarios (useEffect)</a
              >
            </li>
            <li>
              <a href="#estados-complejos-usereducer"
                >Estados complejos (useReducer)</a
              >
            </li>
            <li>
              <a href="#context-api-usecontext">Context API (useContext)</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="#fetch">Fetch</a>
          <ul>
            <li>
              <a href="#ejemplo-basico-then">Ejemplo básico con .then()</a>
            </li>
            <li>
              <a href="#ejemplo-moderno-async-await"
                >Ejemplo moderno con async/await</a
              >
            </li>
            <li>
              <a href="#cleanup-abort-controller"
                >Cleanup con AbortController</a
              >
            </li>
            <li>
              <a href="#manejo-de-errores-y-carga">Manejo de errores y carga</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="#react-router">React Router</a>
          <ul>
            <li>
              <a href="#estructura-de-un-react-router"
                >Estructura de un react router</a
              >
            </li>
            <li><a href="#tipos-de-routers">Tipos de routers</a></li>
            <li><a href="#instalacion">Instalación</a></li>
            <li>
              <a href="#rutas-estaticas-hashrouter"
                >Rutas estáticas (HashRouter)</a
              >
            </li>
            <li><a href="#navegacion-navlink">Navegación (NavLink)</a></li>
            <li>
              <a href="#rutas-dinamicas-useparams"
                >Rutas dinámicas (useParams)</a
              >
            </li>
            <li>
              <a href="#rutas-anidadas-outlet">Rutas anidadas (Outlet)</a>
            </li>
          </ul>
        </li>
        <li>
          <a href="#autenticacion">Autenticación</a>
          <ul>
            <li>
              <a href="#proteger-rutas-con-autenticacion"
                >proteger rutas con autenticación</a
              >
            </li>
            <li>
              <a href="#proteccion-de-rutas-con-redireccionamiento"
                >Protección de rutas con redireccionamiento</a
              >
            </li>
            <li><a href="#roles-y-autorizacion">Roles y autorización</a></li>
          </ul>
        </li>
      </ul>
    </nav>

    <!-- contenido principal -->
    <main>
      <h1>React</h1>
      <h2 id="introduccion">Introducción</h2>
      <hr />

      <p>
        React es una librería de JavaScript orientada a la construcción de
        interfaces de usuario mediante un modelo declarativo basado en
        componentes. En React, la interfaz se define como una función del estado
        de la aplicación: cada vez que el estado cambia, React recalcula la
        representación de la UI y aplica al DOM real únicamente las diferencias
        necesarias.
      </p>

      <p>
        Para lograr esto, React utiliza una estructura interna conocida como
        Virtual DOM, que mantiene una representación en memoria del árbol de
        componentes. Mediante un proceso de reconciliation, React compara el
        árbol anterior con el nuevo y ejecuta actualizaciones mínimas sobre el
        DOM del navegador, optimizando el rendimiento.
      </p>

      <p>
        React implementa un flujo de datos unidireccional (one-way data
        binding), donde los cambios de estado se propagan desde componentes
        padres hacia hijos a través de props. Esta arquitectura favorece la
        previsibilidad del comportamiento de la aplicación y simplifica el
        razonamiento sobre el estado.
      </p>

      <p>
        Aunque React puede utilizarse para desarrollar Single Page Applications
        (SPA), no impone una arquitectura completa de aplicación.
        Funcionalidades como ruteo, gestión global del estado, manejo de efectos
        laterales y persistencia se integran mediante herramientas del
        ecosistema (por ejemplo, React Router, Context, Redux, entre otras).
      </p>

      <h2 id="empezar-un-proyecto">Empezar un proyecto</h2>
      <hr />
      <p>
        Para empezar a desarrollar nuestro frontend con react tenemos que estar
        parados en el root de nuestro proyecto y corremos el comando
        <code>pnpm create vite@latest</code> aquí seleccionamos las
        configuraciones para trabajar con react y esto nos creara la carpeta
        para el frontend.
      </p>

      <p>
        Esta carpeta viene con las configuraciones para usar react como
        node_modules, public, src, … etc. Y donde una vez tengamos listo el
        frontend para produccion corremos el comando npm run build.
      </p>
      <p>
        Dentro de src nos crea la carpeta de assets para las imágenes y 4
        archivos más, dos de estos archivo (main.jsx y index.css) son los
        principales, el archivo jsx es el que va a manejar toda la parte de
        renderizado en el DOM y el css es el que va a tener los estilos
        principales. Por otro lado, los archivos (app.css y app.jsx) son los
        archivos secundarios con una muestra de un componente de react en el
        archivo jsx, y los estilos del mismo en el archivo css.
      </p>
      <pre><code>function App() {
  const items = [&quot;react&quot;, &quot;javascript&quot;, &quot;git&quot;];
  return (
    &lt;section&gt;
      &lt;h1&gt;Hola mundo&lt;/h1&gt;
      &lt;ul&gt;
        {items.map((item, index) =&gt; (
          &lt;li key={index}&gt;{item}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/section&gt;
  );
}</code></pre>
      <p>
        En este ejemplo, usamos map() para renderizar una lista de elementos de
        forma declarativa, sin manipular el DOM manualmente.
      </p>
      <p>Las ventajas de este enfoque son evidentes:</p>
      <ul>
        <li>Código más declarativo y legible</li>
        <li>No es necesario manipular el DOM directamente</li>
        <li>Menos líneas de código para lograr el mismo resultado</li>
        <li>Mayor facilidad para mantener y actualizar</li>
      </ul>

      <h3 id="tailwind-en-react-con-vite">
        <em>Tailwind en react con vite</em>
      </h3>
      <p>
        Existen dos formas de instalar Tailwind CSS en un proyecto de React con
        Vite: la versión 3 (estándar y más utilizada) y la versión 4 (más nueva
        y simplificada).
      </p>

      <h4>Tailwind CSS v3 (Instalación estándar)</h4>
      <p>
        Esta es la forma más común y estable. Primero instalamos las
        dependencias necesarias:
      </p>
      <pre><code>pnpm install -D tailwindcss postcss autoprefixer
pnpm dlx tailwindcss init -p</code></pre>
      <p>
        Esto creará dos archivos: <code>tailwind.config.js</code> y
        <code>postcss.config.js</code>. Configuramos el
        <code>tailwind.config.js</code> para indicar dónde están nuestros
        archivos:
      </p>
      <pre><code>export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}</code></pre>
      <p>
        Luego, en el archivo <code>src/index.css</code> agregamos las directivas
        de Tailwind:
      </p>
      <pre><code>@tailwind base;
@tailwind components;
@tailwind utilities;</code></pre>
      <p>
        Y listo, ya podemos empezar a usar tailwind dentro de nuestros
        componentes en react.
      </p>

      <h4>Tailwind CSS v4 (Nueva versión simplificada)</h4>
      <p>
        La versión 4 simplifica el proceso de instalación. Instalamos tailwind
        con:
      </p>
      <pre><code>pnpm install -D tailwindcss @tailwindcss/vite</code></pre>
      <p>
        Después lo agregamos a la configuración en
        <code>vite.config.js</code>:
      </p>
      <pre><code>import { defineConfig } from 'vite';
import tailwindcss from '@tailwindcss/vite';

export default defineConfig({
  plugins: [
    tailwindcss(),
  ],
});</code></pre>
      <p>
        Y en el archivo <code>src/index.css</code> simplemente importamos
        tailwind:
      </p>
      <pre><code>@import "tailwindcss";</code></pre>
      <p>
        Con cualquiera de las dos versiones ya podemos usar las clases de
        Tailwind en nuestros componentes como si fuera HTML común.
      </p>

      <h2 id="componentes">Componentes</h2>
      <hr />
      <p>
        React simplifica el desarrollo de aplicaciones web al dejarnos hacer
        código en componentes reusables. Un componente en React es una función
        que devuelve algo que queremos que se muestre en la pantalla. Usualmente
        dichas funciones se crean como arrow functions para hacerlas más
        sencillas, aunque de igual manera está bien. Típicamente los componentes
        comienzan con una letra mayuscula para distinguirlos de las etiquetas de
        HTML, veamos un ejemplo
      </p>
      <pre><code>const MyComponent = () =&gt; { return "I'm a component"};</code></pre>
      <p>
        En React, los componentes no solo pueden devolver texto plano, también
        pueden devolver HTML. Por ejemplo
      </p>
      <pre><code>const Bienvenida = () =&gt; {
  return &lt;h1&gt;Hola, mundo&lt;/h1&gt;
};</code></pre>
      <p>
        A esto se le conoce como JSX, que parece HTML pero no lo es. Es una
        sintaxis especial que React usa para escribir código como HTML dentro de
        JavaScript.
      </p>
      <p>
        Para usar un componente dentro de otro, simplemente lo llamamos como si
        fuera una etiqueta HTML. Por ejemplo
      </p>
      <pre><code>const App = () =&gt; {
  return (
    &lt;section&gt;
      &lt;Bienvenida /&gt;
    &lt;/section&gt;
  );
};</code></pre>
      <p>
        Esto hace que el componente Bienvenida se renderice dentro del
        componente App.
      </p>

      <h3 id="props"><em>Props</em></h3>
      <p>
        Las props (abreviatura de &quot;properties&quot; o propiedades) son el
        mecanismo que React utiliza para pasar datos de un componente padre a un
        componente hijo. Funcionan como parámetros que permiten personalizar los
        componentes y hacerlos verdaderamente reutilizables. Por ejemplo
      </p>
      <pre><code>const Card = ({ title, content }) =&gt; {
  return (
    &lt;div&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;p&gt;{content}&lt;/p&gt;
    &lt;/div&gt;
  );
};

export default Card;</code></pre>

      <p>
        En este ejemplo creamos un componente, usamos las propiedades title y
        content, y exportamos el componente.
      </p>
      <p>
        Para usar el componente lo usamos como si fuera una etiqueta html y
        definiendo en los atributos el contenido de las propiedades.
      </p>
      <pre><code >import Card from &quot;./components/Card&quot;;

function App() {
  return (
    &lt;section&gt;
      &lt;Card title=&quot;Cart uno&quot; content=&quot;Esta es una descripción&quot; /&gt;
    &lt;/section&gt;
  );
}

export default App;</code></pre>
      <p>
        Aquí importamos el componente Card y lo usamos dentro del componente
        App, pasando valores específicos para las props title y content.
      </p>

      <h3 id="estados-usestate"><em>Estados (useState) </em></h3>
      <p>
        El estado en React es un mecanismo para almacenar información que puede
        cambiar durante el ciclo de vida de un componente. Podemos visualizarlo
        como cajas de almacenamiento donde guardamos datos específicos que
        nuestros componentes necesitan para funcionar correctamente.
      </p>
      <p>Existen dos tipos principales de estados:</p>

      <ul>
        <li>
          Estado local: Información almacenada a nivel de componente, accesible
          solo dentro del componente donde se define.
        </li>
        <li>
          Estado global: Información compartida entre múltiples componentes de
          la aplicación.
        </li>
      </ul>

      <p>
        React proporciona una herramienta especial llamada useState, que es un
        hook que nos permite implementar estados locales en nuestros componentes
        funcionales. Este hook nos devuelve:
      </p>

      <ul>
        <li>Una variable para leer el valor actual del estado</li>
        <li>Una función para actualizar ese valor</li>
        <li>El valor inicial del estado</li>
      </ul>

      <p>La sintaxis básica es</p>
      <pre><code>const [valor, setValor] = useState(valorInicial);</code></pre>

      <p>
        donde <code>valor</code> es la variable que contiene el estado actual,
        <code>setValor</code> es la función que nos permite actualizar ese
        estado y <code>valorInicial</code> es el valor que con el que comienza
        el estado.
      </p>

      <p>Ejemplo</p>
      <pre><code>import { useState } from 'react';

const Counter = () =&gt; {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;h2&gt;El contador está en: {count}&lt;/h2&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Incrementar&lt;/button&gt;
      &lt;button onClick={() =&gt; setCount(count - 1)}&gt;Decrementar&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
      <p>
        Los estados locales son extremadamente versátiles y pueden utilizarse en
        numerosos escenarios:
      </p>
      <ul>
        <li>
          Formularios: Para almacenar los valores de los campos mientras el
          usuario los completa
        </li>
        <li>
          Toggles: Para manejar estados de activado/desactivado (como menús
          desplegables)
        </li>
        <li>
          Filtros: Para almacenar criterios de filtrado en listas o colecciones
        </li>
        <li>Paginación: Para mantener el número de página actual</li>
        <li>
          Cargas de datos: Para indicar si los datos están cargando, se han
          cargado correctamente o ha ocurrido un error
        </li>
      </ul>

      <h4>Ejemplo de toggle button</h4>
      <pre><code>import { useState } from 'react';

const ToggleButton = () =&gt; {
  const [isActive, setIsActive] = useState(false);

  return (
    &lt;button onClick={() =&gt; setIsActive(!isActive)}&gt;
      {isActive ? &#x27;Activo&#x27; : &#x27;Inactivo&#x27;}
    &lt;/button&gt;
  );
};</code></pre>

      <h4>Ejemplo de variable en formulario</h4>
      <pre><code>import { useState } from 'react';

const NameForm = () =&gt; {
  const [name, setName] = useState(&#x27;&#x27;);

  return (
    &lt;div&gt;
      &lt;input
        type=&quot;text&quot;
        value={name}
        placeholder=&quot;Ingresa tu nombre&quot;
        onChange={(event) =&gt; setName(event.target.value)}
      /&gt;
      &lt;p&gt;Hola, {name ? name : &#x27;visitante&#x27;}&lt;/p&gt;
    &lt;/div&gt;
  );
};</code></pre>

      <h4 id="multiples-estados-en-un-componente">
        Múltiples estados en un componente
      </h4>
      <p>
        En la mayoría de los casos, un componente necesita más de una variable
        de estado. Podemos utilizar múltiples llamadas a useState dentro del
        mismo componente:
      </p>
      <pre><code>import { useState } from 'react';

const UserProfile = () =&gt; {
  const [name, setName] = useState(&#x27;&#x27;);
  const [email, setEmail] = useState(&#x27;&#x27;);
  const [age, setAge] = useState(0);

  return (
    &lt;div&gt;
      &lt;input
        type=&quot;text&quot;
        placeholder=&quot;Nombre&quot;
        value={name}
        onChange={(e) =&gt; setName(e.target.value)}
      /&gt;
      &lt;input
        type=&quot;email&quot;
        placeholder=&quot;Email&quot;
        value={email}
        onChange={(e) =&gt; setEmail(e.target.value)}
      /&gt;
      &lt;input
        type=&quot;number&quot;
        placeholder=&quot;Edad&quot;
        value={age}
        onChange={(e) =&gt; setAge(Number(e.target.value))}
      /&gt;
      &lt;p&gt;Perfil: {name} ({age} años) - {email}&lt;/p&gt;
    &lt;/div&gt;
  );
};</code></pre>
      <h4 id="actualizacion-basada-en-el-estado-anterior">
        Actualización basada en el estado anterior
      </h4>
      <p>
        A veces necesitamos actualizar el estado basándonos en su valor
        anterior. En lugar de pasar un valor directamente, podemos pasar una
        función que recibe el estado anterior y retorna el nuevo estado:
      </p>
      <pre><code>import { useState } from 'react';

const CounterAdvanced = () =&gt; {
  const [count, setCount] = useState(0);

  // Forma correcta: pasar una función
  const increment = () =&gt; {
    setCount((prevCount) =&gt; prevCount + 1);
  };

  const decrement = () =&gt; {
    setCount((prevCount) =&gt; prevCount - 1);
  };

  const reset = () =&gt; {
    setCount(0);
  };

  return (
    &lt;div&gt;
      &lt;p&gt;Contador: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;Incrementar&lt;/button&gt;
      &lt;button onClick={decrement}&gt;Decrementar&lt;/button&gt;
      &lt;button onClick={reset}&gt;Reiniciar&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
      <p>
        Esta forma de actualizar es especialmente importante cuando realizas
        múltiples actualizaciones del estado en rápida sucesión o cuando la
        actualización depende del estado anterior. React agrupa las
        actualizaciones (batching) para optimizar el rendimiento, por lo que
        siempre es recomendable usar la función callback cuando el nuevo estado
        depende del anterior.
      </p>

      <h3 id="efectos-secundarios-useeffect">
        <em>Efectos secundarios (useEffect)</em>
      </h3>
      <p>
        Los efectos secundarios son operaciones que ocurren fuera del flujo
        principal de renderizado de React. Estos incluyen:
      </p>
      <ul>
        <li>Llamadas a APIs externas</li>
        <li>Suscripciones a eventos</li>
        <li>Manipulación del DOM</li>
        <li>Temporizadores (setTimeout, setInterval)</li>
        <li>Almacenamiento en localStorage</li>
      </ul>
      <p>
        El hook useEffect fue diseñado específicamente para manejar estos
        efectos secundarios, permitiéndonos ejecutar código después de que el
        componente se haya renderizado en la pantalla.
      </p>
      <p>El hook useEffect recibe dos parámetros:</p>
      <ul>
        <li>Una función que contiene el código a ejecutar</li>
        <li>
          Un array de dependencias (opcional) que determina cuándo se ejecutará
          el efecto
        </li>
      </ul>
      <pre><code>useEffect(() =&gt; {}, [dependencias]);</code></pre>
      <p>
        Si el array de dependencias está vacío [], el efecto se ejecutará solo
        una vez después del primer renderizado. Si incluimos variables en el
        array, el efecto se ejecutará cada vez que alguna de esas variables
        cambie de valor.
      </p>
      <p>Ejemplo básico con dependencias:</p>
      <pre><code>import { useState, useEffect } from 'react';

const CounterWithEffect = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log(`El contador cambió a ${count}`);
  }, [count]);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Incrementar&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
      <p>
        El hook useEffect es extremadamente versátil y puede utilizarse en
        numerosos escenarios:
      </p>
      <ul>
        <li>
          Obtención de datos: Realizar peticiones a APIs cuando un componente se
          monta o cuando cambian ciertos parámetros
        </li>
        <li>
          Suscripciones: Establecer listeners de eventos y limpiarlos cuando el
          componente se desmonta
        </li>
        <li>
          Manipulación del DOM: Actualizar el título de la página o interactuar
          con elementos del DOM
        </li>
        <li>
          Animaciones: Iniciar o detener animaciones basadas en cambios de
          estado
        </li>
        <li>
          Persistencia de datos: Guardar información en localStorage cuando
          cambian ciertos valores
        </li>
      </ul>

      <h4 id="funcion-cleanup-useeffect">Función cleanup en useEffect</h4>
      <p>
        Cuando necesitamos limpiar recursos (suscripciones, timers, listeners),
        podemos retornar una función desde useEffect que se ejecutará al
        desmontar el componente o antes de ejecutar el efecto nuevamente:
      </p>
      <pre><code>import { useState, useEffect } from 'react';

const SubscriptionExample = () =&gt; {
  const [isSubscribed, setIsSubscribed] = useState(false);

  useEffect(() =&gt; {
    // Setup: ejecuta cuando el componente monta
    if (isSubscribed) {
      console.log('Suscrito a eventos');
      const handleEvent = () =&gt; console.log('Evento disparado');
      window.addEventListener('scroll', handleEvent);

      // Cleanup: se ejecuta antes de desmontar o antes del siguiente efecto
      return () =&gt; {
        console.log('Desuscrito de eventos');
        window.removeEventListener('scroll', handleEvent);
      };
    }
  }, [isSubscribed]);

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setIsSubscribed(!isSubscribed)}&gt;
        {isSubscribed ? 'Desuscribirse' : 'Suscribirse'}
      &lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>

      <h4 id="useeffect-sin-dependencias-monta-y-desmonta">
        useEffect sin dependencias (monta y desmonta)
      </h4>
      <pre><code>import { useState, useEffect } from 'react';

const TimerExample = () =&gt; {
  const [seconds, setSeconds] = useState(0);

  useEffect(() =&gt; {
    // Corre una sola vez cuando el componente monta
    const interval = setInterval(() =&gt; {
      setSeconds((prev) =&gt; prev + 1);
    }, 1000);

    // Cleanup: se ejecuta cuando el componente desmonta
    return () =&gt; clearInterval(interval);
  }, []); // Array vacío = solo al montar/desmontar

  return &lt;p&gt;Tiempo: {seconds} segundos&lt;/p&gt;;
};</code></pre>

      <h4 id="useeffect-para-obtener-datos">useEffect para obtener datos</h4>
      <pre><code>import { useState, useEffect } from 'react';

const DataFetcher = ({ userId }) =&gt; {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    // Reset states
    setLoading(true);
    setError(null);

    // Fetch de datos
    fetch(`https://api.example.com/users/${userId}`)
      .then((response) =&gt; {
        if (!response.ok) throw new Error('Error en la API');
        return response.json();
      })
      .then((data) =&gt; setUser(data))
      .catch((err) =&gt; setError(err.message))
      .finally(() =&gt; setLoading(false));
  }, [userId]); // Se ejecuta cada vez que userId cambia

  if (loading) return &lt;p&gt;Cargando...&lt;/p&gt;;
  if (error) return &lt;p&gt;Error: {error}&lt;/p&gt;;
  return &lt;div&gt;&lt;h2&gt;{user?.name}&lt;/h2&gt;&lt;/div&gt;;
};</code></pre>
      <p>
        <strong>Importante:</strong> La función cleanup retornada desde
        useEffect es esencial para evitar memory leaks. Siempre limpia
        listeners, timers, o suscripciones que hayas establecido en el efecto.
      </p>

      <h3 id="estados-complejos-usereducer">
        <em>Estados complejos (useReducer)</em>
      </h3>
      <p>
        A diferencia de useState, que simplemente reemplaza el estado anterior,
        useReducer permite definir una función reductora (reducer) que
        especifica cómo el estado debe cambiar en respuesta a diferentes
        acciones. Esta estructura se asemeja al patrón de diseño Redux, pero
        integrado directamente en React.
      </p>
      <p>La sintaxis básica de useReducer incluye:</p>
      <pre><code>const [state, dispatch] = useReducer(reducer, initialState);</code></pre>
      <p>
        Donde <code>state</code> es el estado actual, <code>dispatch</code> es
        una función para enviar acciones al reducer, <code>reducer</code> es una
        función que determina cómo actualizar el estado basado en la acción, e
        <code>initialState</code> es el valor inicial.
      </p>
      <h4 id="cuando-usar-usereducer">
        ¿Cuándo usar useReducer en lugar de useState?
      </h4>
      <p>Usa useReducer cuando:</p>
      <ul>
        <li>El estado tiene múltiples valores relacionados entre sí</li>
        <li>
          La lógica de actualización es compleja o tiene muchas condiciones
        </li>
        <li>
          El siguiente estado depende del estado anterior de forma compleja
        </li>
        <li>
          Quieres optimizar el rendimiento en componentes grandes (dispatch no
          cambia entre renders)
        </li>
        <li>Necesitas una lógica de estado más predecible y testeable</li>
      </ul>
      <p>Usa useState cuando:</p>
      <ul>
        <li>El estado es un valor simple (string, number, boolean)</li>
        <li>Las actualizaciones son directas y simples</li>
        <li>No hay mucha lógica condicional en las actualizaciones</li>
      </ul>

      <h4 id="ejemplo-basico-contador">Ejemplo básico: Contador</h4>
      <p>
        Empezamos definiendo la función reducer, esta recibirá dos argumentos,
        el primero es el estado y el segundo es la acción.
      </p>
      <pre><code>import { useReducer } from &#x27;react&#x27;;

// Función reducer
const reducer = (state, action) =&gt; {
  // definimos acciones según el tipo de acción
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    case "reset":
      return { count: 0 };
    default:
      return state;
  }
};

// Componente
const Counter = () =&gt; {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    &lt;div&gt;
      &lt;p&gt;Contador: {state.count}&lt;/p&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#x27;increment&#x27; })}&gt;
        Incrementar
      &lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#x27;decrement&#x27; })}&gt;
        Decrementar
      &lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#x27;reset&#x27; })}&gt;
        Reiniciar
      &lt;/button&gt;
    &lt;/div&gt;
  );
};

export default Counter;</code></pre>

      <h4 id="ejemplo-con-payload-carrito-de-compras">
        Ejemplo con payload: Carrito de compras
      </h4>
      <p>
        Las acciones pueden incluir datos adicionales (payload) para actualizar
        el estado. Veamos un ejemplo más complejo con un carrito de compras:
      </p>
      <pre><code>import { useReducer } from &#x27;react&#x27;;

// Mejores prácticas: usar constantes para los tipos de acción
const ACTIONS = {
  ADD_ITEM: &#x27;add_item&#x27;,
  REMOVE_ITEM: &#x27;remove_item&#x27;,
  UPDATE_QUANTITY: &#x27;update_quantity&#x27;,
  CLEAR_CART: &#x27;clear_cart&#x27;
};

// Reducer con lógica compleja
const cartReducer = (state, action) =&gt; {
  switch (action.type) {
    case ACTIONS.ADD_ITEM: {
      const existingItem = state.items.find(
        item =&gt; item.id === action.payload.id
      );

      if (existingItem) {
        return {
          ...state,
          items: state.items.map(item =&gt;
            item.id === action.payload.id
              ? { ...item, quantity: item.quantity + 1 }
              : item
          )
        };
      }

      return {
        ...state,
        items: [...state.items, { ...action.payload, quantity: 1 }]
      };
    }

    case ACTIONS.REMOVE_ITEM:
      return {
        ...state,
        items: state.items.filter(item =&gt; item.id !== action.payload.id)
      };

    case ACTIONS.UPDATE_QUANTITY:
      return {
        ...state,
        items: state.items.map(item =&gt;
          item.id === action.payload.id
            ? { ...item, quantity: action.payload.quantity }
            : item
        )
      };

    case ACTIONS.CLEAR_CART:
      return { items: [] };

    default:
      return state;
  }
};

// Componente del carrito
const ShoppingCart = () =&gt; {
  const [state, dispatch] = useReducer(cartReducer, { items: [] });

  const addItem = (item) =&gt; {
    dispatch({ type: ACTIONS.ADD_ITEM, payload: item });
  };

  const removeItem = (id) =&gt; {
    dispatch({ type: ACTIONS.REMOVE_ITEM, payload: { id } });
  };

  const updateQuantity = (id, quantity) =&gt; {
    dispatch({
      type: ACTIONS.UPDATE_QUANTITY,
      payload: { id, quantity }
    });
  };

  const clearCart = () =&gt; {
    dispatch({ type: ACTIONS.CLEAR_CART });
  };

  const total = state.items.reduce(
    (sum, item) =&gt; sum + item.price * item.quantity,
    0
  );

  return (
    &lt;div&gt;
      &lt;h2&gt;Carrito de Compras&lt;/h2&gt;
      &lt;ul&gt;
        {state.items.map(item =&gt; (
          &lt;li key={item.id}&gt;
            {item.name} - ${item.price} x {item.quantity}
            &lt;button onClick={() =&gt; updateQuantity(item.id, item.quantity + 1)}&gt;
              +
            &lt;/button&gt;
            &lt;button onClick={() =&gt; updateQuantity(item.id, item.quantity - 1)}&gt;
              -
            &lt;/button&gt;
            &lt;button onClick={() =&gt; removeItem(item.id)}&gt;
              Eliminar
            &lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;p&gt;Total: ${total.toFixed(2)}&lt;/p&gt;
      &lt;button onClick={() =&gt; addItem({ id: 1, name: &#x27;Producto 1&#x27;, price: 10 })}&gt;
        Agregar Producto 1
      &lt;/button&gt;
      &lt;button onClick={clearCart}&gt;Limpiar Carrito&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default ShoppingCart;</code></pre>

      <h4 id="mejores-practicas-usereducer">
        Mejores prácticas con useReducer
      </h4>
      <ul>
        <li>
          Usa constantes para los tipos de acción: Evita errores de tipeo y
          facilita el refactoring
        </li>
        <li>
          El reducer debe ser puro: No debe tener efectos secundarios ni
          mutaciones directas
        </li>
        <li>
          Retorna siempre un nuevo objeto: Usa el spread operator (...) para
          crear nuevos objetos en lugar de modificar el estado directamente
        </li>
        <li>
          Incluye un caso default: Siempre retorna el estado actual si la acción
          no coincide
        </li>
        <li>
          Usa payload para datos adicionales: Envía información adicional en la
          propiedad payload de la acción
        </li>
      </ul>

      <h3 id="context-api-usecontext"><em>Context API (useContext)</em></h3>
      <p>
        Context API es una funcionalidad nativa de React que permite compartir
        datos entre componentes sin tener que pasar props manualmente a través
        de cada nivel del árbol de componentes. Resuelve el problema conocido
        como "prop drilling".
      </p>

      <h4 id="problema-prop-drilling">El problema: Prop Drilling</h4>
      <p>
        Cuando necesitas pasar datos a un componente profundamente anidado,
        tienes que pasar props a través de todos los componentes intermedios,
        incluso si esos componentes no usan esos datos:
      </p>
      <pre><code>function App() {
  const [user, setUser] = useState({ name: &quot;Juan&quot; });

  return &lt;Header user={user} /&gt;;
}

function Header({ user }) {
  // Header no usa user, solo lo pasa
  return &lt;Navbar user={user} /&gt;;
}

function Navbar({ user }) {
  // Navbar tampoco usa user, solo lo pasa
  return &lt;UserMenu user={user} /&gt;;
}

function UserMenu({ user }) {
  // Finalmente, UserMenu sí usa user
  return &lt;p&gt;Hola, {user.name}&lt;/p&gt;;
}</code></pre>
      <p>
        Este patrón se vuelve problemático en aplicaciones grandes donde los
        datos deben atravesar muchos niveles de componentes.
      </p>

      <h4 id="componentes-context-api">Componentes de Context API</h4>
      <p>Context API se compone de tres elementos principales:</p>

      <h5>1. createContext - Crear el contexto</h5>
      <p>
        Primero creamos un contexto que actuará como el "contenedor" de nuestros
        datos:
      </p>
      <pre><code>import React from &#x27;react&#x27;;

const UserContext = React.createContext();</code></pre>

      <h5>2. Provider - Proveer los valores</h5>
      <p>
        El Provider envuelve los componentes que necesitan acceso al contexto y
        les proporciona el valor:
      </p>
      <pre><code>function App() {
  const [user, setUser] = useState({ name: &quot;Juan&quot; });

  return (
    &lt;UserContext.Provider value={{ user, setUser }}&gt;
      &lt;Header /&gt;
    &lt;/UserContext.Provider&gt;
  );
}</code></pre>

      <h5>3. useContext - Consumir los valores</h5>
      <p>
        Los componentes hijos pueden acceder al valor directamente con el hook
        <code>useContext</code>, sin importar qué tan profundo estén en el
        árbol:
      </p>
      <pre><code>function UserMenu() {
  const { user } = useContext(UserContext);

  return &lt;p&gt;Hola, {user.name}&lt;/p&gt;;
}</code></pre>

      <h4 id="ejemplo-completo-context">Ejemplo completo: Sistema de temas</h4>
      <p>
        Vamos a crear un sistema de temas (claro/oscuro) usando Context API:
      </p>
      <pre><code>import React, { createContext, useContext, useState } from &#x27;react&#x27;;

// 1. Crear el contexto
const ThemeContext = createContext();

// 2. Crear el Provider personalizado
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState(&#x27;light&#x27;);

  const toggleTheme = () =&gt; {
    setTheme(prev =&gt; prev === &#x27;light&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27;);
  };

  const value = { theme, toggleTheme };

  return (
    &lt;ThemeContext.Provider value={value}&gt;
      {children}
    &lt;/ThemeContext.Provider&gt;
  );
}

// 3. Crear un hook personalizado para facilitar el uso
function useTheme() {
  const context = useContext(ThemeContext);

  if (!context) {
    throw new Error(&#x27;useTheme debe usarse dentro de ThemeProvider&#x27;);
  }

  return context;
}

// 4. Exportar
export { ThemeProvider, useTheme };</code></pre>

      <p>Ahora podemos usar este contexto en nuestra aplicación:</p>
      <pre><code>// App.jsx
import { ThemeProvider } from &#x27;./ThemeContext&#x27;;

function App() {
  return (
    &lt;ThemeProvider&gt;
      &lt;Header /&gt;
      &lt;MainContent /&gt;
      &lt;Footer /&gt;
    &lt;/ThemeProvider&gt;
  );
}

// Header.jsx
import { useTheme } from &#x27;./ThemeContext&#x27;;

function Header() {
  const { theme, toggleTheme } = useTheme();

  return (
    &lt;header style={{ background: theme === &#x27;light&#x27; ? &#x27;#fff&#x27; : &#x27;#333&#x27; }}&gt;
      &lt;h1&gt;Mi App&lt;/h1&gt;
      &lt;button onClick={toggleTheme}&gt;
        Cambiar a {theme === &#x27;light&#x27; ? &#x27;oscuro&#x27; : &#x27;claro&#x27;}
      &lt;/button&gt;
    &lt;/header&gt;
  );
}

// MainContent.jsx
function MainContent() {
  const { theme } = useTheme();

  return (
    &lt;main style={{
      background: theme === &#x27;light&#x27; ? &#x27;#f0f0f0&#x27; : &#x27;#222&#x27;,
      color: theme === &#x27;light&#x27; ? &#x27;#000&#x27; : &#x27;#fff&#x27;
    }}&gt;
      &lt;p&gt;Contenido principal&lt;/p&gt;
    &lt;/main&gt;
  );
}</code></pre>

      <h4 id="context-con-usereducer">Combinando Context API con useReducer</h4>
      <p>
        Para estado más complejo, es común combinar Context API con useReducer.
        Esto nos da las ventajas de ambos: estado global con lógica de
        actualización compleja y predecible:
      </p>
      <pre><code>import React, { createContext, useContext, useReducer } from &#x27;react&#x27;;

// Definimos las acciones
const ACTIONS = {
  ADD_ITEM: &#x27;add_item&#x27;,
  REMOVE_ITEM: &#x27;remove_item&#x27;,
  CLEAR_CART: &#x27;clear_cart&#x27;
};

// Reducer
function cartReducer(state, action) {
  switch (action.type) {
    case ACTIONS.ADD_ITEM:
      return {
        ...state,
        items: [...state.items, action.payload]
      };
    case ACTIONS.REMOVE_ITEM:
      return {
        ...state,
        items: state.items.filter(item =&gt; item.id !== action.payload.id)
      };
    case ACTIONS.CLEAR_CART:
      return { items: [] };
    default:
      return state;
  }
}

// Context
const CartContext = createContext();

// Provider
function CartProvider({ children }) {
  const [state, dispatch] = useReducer(cartReducer, { items: [] });

  // Funciones helper que usan dispatch
  const addItem = (item) =&gt; {
    dispatch({ type: ACTIONS.ADD_ITEM, payload: item });
  };

  const removeItem = (id) =&gt; {
    dispatch({ type: ACTIONS.REMOVE_ITEM, payload: { id } });
  };

  const clearCart = () =&gt; {
    dispatch({ type: ACTIONS.CLEAR_CART });
  };

  const value = {
    items: state.items,
    addItem,
    removeItem,
    clearCart
  };

  return &lt;CartContext.Provider value={value}&gt;{children}&lt;/CartContext.Provider&gt;;
}

// Hook personalizado
function useCart() {
  const context = useContext(CartContext);
  if (!context) {
    throw new Error(&#x27;useCart debe usarse dentro de CartProvider&#x27;);
  }
  return context;
}

export { CartProvider, useCart };</code></pre>

      <p>Usando el carrito en componentes:</p>
      <pre><code>// App.jsx
function App() {
  return (
    &lt;CartProvider&gt;
      &lt;ProductList /&gt;
      &lt;Cart /&gt;
    &lt;/CartProvider&gt;
  );
}

// ProductList.jsx
function ProductList() {
  const { addItem } = useCart();

  const products = [
    { id: 1, name: &#x27;Laptop&#x27;, price: 999 },
    { id: 2, name: &#x27;Mouse&#x27;, price: 29 }
  ];

  return (
    &lt;div&gt;
      {products.map(product =&gt; (
        &lt;div key={product.id}&gt;
          &lt;h3&gt;{product.name}&lt;/h3&gt;
          &lt;p&gt;${product.price}&lt;/p&gt;
          &lt;button onClick={() =&gt; addItem(product)}&gt;
            Agregar al carrito
          &lt;/button&gt;
        &lt;/div&gt;
      ))}
    &lt;/div&gt;
  );
}

// Cart.jsx
function Cart() {
  const { items, removeItem, clearCart } = useCart();

  const total = items.reduce((sum, item) =&gt; sum + item.price, 0);

  return (
    &lt;div&gt;
      &lt;h2&gt;Carrito ({items.length} items)&lt;/h2&gt;
      {items.map(item =&gt; (
        &lt;div key={item.id}&gt;
          &lt;span&gt;{item.name} - ${item.price}&lt;/span&gt;
          &lt;button onClick={() =&gt; removeItem(item.id)}&gt;Eliminar&lt;/button&gt;
        &lt;/div&gt;
      ))}
      &lt;p&gt;Total: ${total}&lt;/p&gt;
      &lt;button onClick={clearCart}&gt;Limpiar carrito&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>

      <h4 id="mejores-practicas-context">Mejores prácticas con Context API</h4>
      <ul>
        <li>
          <strong>Crea un hook personalizado:</strong> En lugar de exportar el
          contexto directamente, crea un hook como <code>useTheme()</code> o
          <code>useCart()</code>
          que valide que se esté usando dentro del Provider correcto.
        </li>
        <li>
          <strong>Separa contextos por dominio:</strong> No pongas todo el
          estado de la app en un solo contexto. Crea contextos separados para
          diferentes áreas (auth, theme, cart, etc.).
        </li>
        <li>
          <strong>Evita re-renders innecesarios:</strong> Si el valor del
          contexto cambia frecuentemente, considera dividirlo en múltiples
          contextos más pequeños.
        </li>
        <li>
          <strong>Memoriza el valor del Provider:</strong> Usa
          <code>useMemo</code> para el objeto value si contiene funciones o
          cálculos costosos.
        </li>
        <li>
          <strong>Coloca el Provider lo más cerca posible:</strong> No envuelvas
          toda la app si solo algunos componentes necesitan el contexto.
        </li>
      </ul>

      <h4 id="cuando-usar-context">¿Cuándo usar Context API?</h4>
      <p>Usar Context API cuando:</p>
      <ul>
        <li>Necesitas evitar prop drilling (pasar props por muchos niveles)</li>
        <li>
          El estado debe ser accesible por muchos componentes en diferentes
          niveles
        </li>
        <li>
          Manejas estado global simple (tema, idioma, usuario autenticado)
        </li>
        <li>Quieres evitar instalar librerías externas como Redux</li>
      </ul>

      <p>No usar Context API cuando:</p>
      <ul>
        <li>El estado es local y solo lo usa un componente</li>
        <li>Solo necesitas pasar props a 1-2 niveles (usa props normales)</li>
        <li>
          El estado cambia muy frecuentemente (puede causar muchos re-renders)
        </li>
        <li>
          Necesitas características avanzadas como time-travel debugging o
          middleware
        </li>
      </ul>

      <h4 id="casos-uso-context">Casos de uso comunes</h4>
      <ul>
        <li>
          <strong>Autenticación:</strong> Usuario logueado, tokens, permisos
        </li>
        <li>
          <strong>Tema:</strong> Dark mode, colores, preferencias visuales
        </li>
        <li><strong>Idioma:</strong> Internacionalización (i18n)</li>
        <li><strong>Configuración:</strong> Ajustes del usuario</li>
        <li>
          <strong>Notificaciones:</strong> Sistema global de alertas/toasts
        </li>
        <li>
          <strong>Carrito de compras:</strong> En aplicaciones de e-commerce
        </li>
      </ul>

      <p>
        <strong>Nota:</strong> En la sección de autenticación de esta
        documentación, verás un ejemplo real de Context API combinado con React
        Router para crear un sistema de login/logout completo.
      </p>

      <h2 id="fetch">Fetch</h2>
      <hr />
      <p>
        Fetch es la API nativa de JavaScript para realizar peticiones HTTP a
        servidores externos. En React, estas peticiones se realizan típicamente
        dentro de useEffect, ya que son efectos secundarios que deben ejecutarse
        después del renderizado inicial del componente.
      </p>
      <p>
        La combinación de useState para almacenar los datos y useEffect para
        obtenerlos es el patrón fundamental para trabajar con APIs en React.
      </p>

      <h3 id="ejemplo-basico-then">Ejemplo básico con .then()</h3>
      <p>Un llamado simple a una API se vería así:</p>
      <pre><code>import { useState, useEffect } from &#x27;react&#x27;;

const UserList = () =&gt; {
  // Estado para almacenar los usuarios
  const [users, setUsers] = useState([]);

  useEffect(() =&gt; {
    // Realizamos la petición HTTP
    fetch(&#x27;https://jsonplaceholder.typicode.com/users&#x27;)
      // Convertimos la respuesta a JSON
      .then(response =&gt; response.json())
      // Guardamos los datos en el estado
      .then(data =&gt; setUsers(data))
      // Manejamos errores básicos
      .catch(error =&gt; console.error(&#x27;Error fetching data:&#x27;, error));
  }, []); // Array vacío = solo se ejecuta al montar

  // Renderizamos la lista
  return (
    &lt;div&gt;
      &lt;h1&gt;Usuarios&lt;/h1&gt;
      &lt;ul&gt;
        {users.map(user =&gt; (
          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};

export default UserList;</code></pre>

      <h3 id="ejemplo-moderno-async-await">Ejemplo moderno con async/await</h3>
      <p>
        La sintaxis moderna con async/await es más legible y fácil de mantener.
        Sin embargo, como useEffect no puede ser directamente async, debemos
        crear una función interna:
      </p>
      <pre><code>import { useState, useEffect } from &#x27;react&#x27;;

const UserList = () =&gt; {
  const [users, setUsers] = useState([]);

  useEffect(() =&gt; {
    // Función async dentro de useEffect
    const fetchUsers = async () =&gt; {
      try {
        const response = await fetch(&#x27;https://jsonplaceholder.typicode.com/users&#x27;);
        const data = await response.json();
        setUsers(data);
      } catch (error) {
        console.error(&#x27;Error fetching data:&#x27;, error);
      }
    };

    // Ejecutamos la función
    fetchUsers();
  }, []);

  return (
    &lt;div&gt;
      &lt;h1&gt;Usuarios&lt;/h1&gt;
      &lt;ul&gt;
        {users.map(user =&gt; (
          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};</code></pre>

      <h3 id="cleanup-abort-controller">Cleanup con AbortController</h3>
      <p>
        Cuando un componente se desmonta mientras una petición está en curso,
        puede causar memory leaks o errores al intentar actualizar el estado.
        AbortController nos permite cancelar peticiones pendientes:
      </p>
      <pre><code>import { useState, useEffect } from &#x27;react&#x27;;

const UserList = () =&gt; {
  const [users, setUsers] = useState([]);

  useEffect(() =&gt; {
    // Creamos un controlador para abortar la petición
    const controller = new AbortController();

    const fetchUsers = async () =&gt; {
      try {
        const response = await fetch(&#x27;https://jsonplaceholder.typicode.com/users&#x27;, {
          signal: controller.signal // Conectamos el signal
        });
        const data = await response.json();
        setUsers(data);
      } catch (error) {
        // Ignoramos errores de abort
        if (error.name !== &#x27;AbortError&#x27;) {
          console.error(&#x27;Error fetching data:&#x27;, error);
        }
      }
    };

    fetchUsers();

    // Cleanup: cancelamos la petición si el componente se desmonta
    return () =&gt; controller.abort();
  }, []);

  return (
    &lt;div&gt;
      &lt;h1&gt;Usuarios&lt;/h1&gt;
      &lt;ul&gt;
        {users.map(user =&gt; (
          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};</code></pre>

      <p>
        <strong>Nota:</strong> Estos ejemplos básicos no incluyen estados de
        carga ni manejo de errores para el usuario. En la siguiente sección
        veremos cómo implementar una solución más completa y profesional.
      </p>

      <h3 id="manejo-de-errores-y-carga">Manejo de errores y carga</h3>
      <p>
        En aplicaciones reales, es crucial comunicar al usuario el estado de las
        peticiones HTTP. Para esto, utilizamos tres estados que trabajan en
        conjunto:
      </p>
      <ul>
        <li><strong>data</strong> (users): Los datos obtenidos de la API</li>
        <li>
          <strong>loading</strong> (isLoading): Indica si la petición está en
          curso
        </li>
        <li>
          <strong>error</strong>: Almacena cualquier error que ocurra durante la
          petición
        </li>
      </ul>
      <p>
        Estos tres estados forman el patrón estándar de manejo de peticiones
        asíncronas en React.
      </p>

      <h4>Implementación básica</h4>
      <pre><code>import { useState, useEffect } from &#x27;react&#x27;;

const UserList = () =&gt; {
  // Estado para los datos
  const [users, setUsers] = useState([]);
  // Estado para la carga
  const [isLoading, setIsLoading] = useState(true);
  // Estado para errores
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    const fetchUsers = async () =&gt; {
      try {
        const response = await fetch(&#x27;https://jsonplaceholder.typicode.com/users&#x27;);

        // Verificamos si la respuesta fue exitosa
        if (!response.ok) {
          throw new Error(`Error HTTP: ${response.status}`);
        }

        const data = await response.json();
        setUsers(data);
      } catch (error) {
        // Guardamos el mensaje de error
        setError(error.message);
      } finally {
        // Siempre desactivamos el loading
        setIsLoading(false);
      }
    };

    // IMPORTANTE: Ejecutamos la función
    fetchUsers();
  }, []);

  // Renderizado condicional: mostramos loading
  if (isLoading) {
    return &lt;p&gt;Cargando usuarios...&lt;/p&gt;;
  }

  // Renderizado condicional: mostramos error
  if (error) {
    return &lt;p&gt;Error: {error}&lt;/p&gt;;
  }

  // Renderizado normal: mostramos los datos
  return (
    &lt;div&gt;
      &lt;h1&gt;Usuarios&lt;/h1&gt;
      &lt;ul&gt;
        {users.map(user =&gt; (
          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};

export default UserList;</code></pre>

      <h4>Implementación profesional con cleanup</h4>
      <p>
        Una implementación más robusta incluye AbortController para cancelar
        peticiones pendientes y evitar actualizaciones de estado en componentes
        desmontados:
      </p>
      <pre><code>import { useState, useEffect } from &#x27;react&#x27;;

const UserList = () =&gt; {
  const [users, setUsers] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    const controller = new AbortController();

    const fetchUsers = async () =&gt; {
      try {
        setIsLoading(true);
        setError(null);

        const response = await fetch(
          &#x27;https://jsonplaceholder.typicode.com/users&#x27;,
          { signal: controller.signal }
        );

        if (!response.ok) {
          throw new Error(`Error HTTP: ${response.status}`);
        }

        const data = await response.json();
        setUsers(data);
      } catch (error) {
        // Ignoramos errores de cancelación
        if (error.name !== &#x27;AbortError&#x27;) {
          setError(error.message);
        }
      } finally {
        setIsLoading(false);
      }
    };

    fetchUsers();

    // Cleanup: cancelamos la petición al desmontar
    return () =&gt; controller.abort();
  }, []);

  if (isLoading) {
    return (
      &lt;div&gt;
        &lt;h1&gt;Usuarios&lt;/h1&gt;
        &lt;p&gt;Cargando usuarios...&lt;/p&gt;
      &lt;/div&gt;
    );
  }

  if (error) {
    return (
      &lt;div&gt;
        &lt;h1&gt;Usuarios&lt;/h1&gt;
        &lt;p style={{ color: &#x27;red&#x27; }}&gt;Error: {error}&lt;/p&gt;
        &lt;button onClick={() =&gt; window.location.reload()}&gt;
          Reintentar
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div&gt;
      &lt;h1&gt;Usuarios ({users.length})&lt;/h1&gt;
      {users.length === 0 ? (
        &lt;p&gt;No hay usuarios disponibles&lt;/p&gt;
      ) : (
        &lt;ul&gt;
          {users.map(user =&gt; (
            &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )}
    &lt;/div&gt;
  );
};

export default UserList;</code></pre>

      <h4>Patrón de estados y flujo</h4>
      <p>El flujo de estados sigue este patrón:</p>
      <ol>
        <li>
          <strong>Estado inicial:</strong> isLoading = true, error = null, data
          = []
        </li>
        <li>
          <strong>Durante la petición:</strong> isLoading permanece en true
        </li>
        <li>
          <strong>Si tiene éxito:</strong> isLoading = false, data se actualiza
        </li>
        <li>
          <strong>Si falla:</strong> isLoading = false, error contiene el
          mensaje
        </li>
      </ol>
      <p>
        <strong>Importante:</strong> El bloque <code>finally</code> garantiza
        que isLoading siempre se desactive, independientemente de si la petición
        fue exitosa o falló.
      </p>

      <h2 id="react-router">React Router</h2>
      <hr />
      <p>
        React Router es la biblioteca estándar para manejar navegación y rutas
        en aplicaciones React. Permite crear Single Page Applications (SPA) con
        navegación entre diferentes vistas sin recargar la página completa.
      </p>
      <p>
        A medida que una aplicación crece, se vuelve esencial implementar una
        estructura organizada que permita la navegación entre diferentes vistas.
        React Router transforma aplicaciones simples en sistemas complejos de
        múltiples páginas, mejorando tanto la navegabilidad como la
        mantenibilidad del código.
      </p>

      <h3 id="estructura-de-un-react-router">Estructura de un react router</h3>
      <p>
        La estructura básica de React Router se compone de varios elementos
        fundamentales que trabajan en conjunto:
      </p>
      <ul>
        <li>
          <strong>Router (Provider):</strong> El componente contenedor principal
          (BrowserRouter, HashRouter, etc.) que proporciona el contexto de
          navegación a toda la aplicación. Similar a React Context, permite que
          los componentes hijos accedan a la información de rutas.
        </li>
        <li>
          <strong>Routes:</strong> Contenedor que agrupa todas las rutas de la
          aplicación. Solo renderiza la primera ruta que coincida con la URL
          actual.
        </li>
        <li>
          <strong>Route:</strong> Define una ruta específica usando las props
          <code>path</code> (URL) y <code>element</code> (componente a
          renderizar).
        </li>
        <li>
          <strong>Link/NavLink:</strong> En lugar de etiquetas
          <code>&lt;a&gt;</code>, React Router usa estos componentes para crear
          enlaces que navegan sin recargar la página.
        </li>
        <li>
          <strong>Outlet:</strong> Placeholder para renderizar rutas anidadas
          dentro de un componente padre.
        </li>
      </ul>
      <p>
        Además, los Routers permiten incluir componentes persistentes como Menús
        o Footers que se mantienen visibles en todas las vistas, asegurando una
        estructura consistente en la aplicación.
      </p>

      <h3 id="tipos-de-routers">Tipos de routers</h3>
      <p>
        React Router DOM ofrece tres tipos principales de routers, cada uno con
        un propósito específico y una manera particular de gestionar la
        navegación:
      </p>

      <h4>BrowserRouter</h4>
      <p>
        El router estándar para aplicaciones web modernas. Utiliza la API de
        History del navegador para crear URLs limpias y legibles, como
        <code>/home</code>, <code>/blog</code> o <code>/contact</code>.
      </p>
      <p>
        <strong>Cuándo usarlo:</strong> En la mayoría de aplicaciones web
        desplegadas en servidores que pueden manejar rutas dinámicas (como
        Vercel, Netlify, o servidores con configuración SPA).
      </p>
      <pre><code>import { BrowserRouter, Routes, Route } from &#x27;react-router-dom&#x27;;

function App() {
  return (
    &lt;BrowserRouter&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;/about&quot; element={&lt;About /&gt;} /&gt;
        &lt;Route path=&quot;/contact&quot; element={&lt;Contact /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
}

// URLs resultantes:
// https://example.com/
// https://example.com/about
// https://example.com/contact</code></pre>

      <h4>HashRouter</h4>
      <p>
        Utiliza el símbolo de hash (<code>#</code>) en la URL para simular
        diferentes rutas. Las URLs se ven como
        <code>example.com/#/about</code> o <code>example.com/#/blog</code>.
      </p>
      <p>
        <strong>Cuándo usarlo:</strong> En entornos donde no tienes control del
        servidor (páginas estáticas, GitHub Pages) o cuando necesitas
        compatibilidad con navegadores antiguos. El servidor solo ve la parte
        antes del <code>#</code>, por lo que no necesita configuración especial.
      </p>
      <pre><code>import { HashRouter, Routes, Route } from &#x27;react-router-dom&#x27;;

function App() {
  return (
    &lt;HashRouter&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;/about&quot; element={&lt;About /&gt;} /&gt;
        &lt;Route path=&quot;/contact&quot; element={&lt;Contact /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/HashRouter&gt;
  );
}

// URLs resultantes:
// https://example.com/#/
// https://example.com/#/about
// https://example.com/#/contact</code></pre>

      <h4>MemoryRouter</h4>
      <p>
        Mantiene el historial de navegación en memoria sin reflejarlo en la URL
        del navegador. La barra de direcciones no cambia al navegar entre rutas.
      </p>
      <p>
        <strong>Cuándo usarlo:</strong> En aplicaciones móviles (React Native),
        entornos de testing, o aplicaciones embebidas donde no se requiere
        sincronización con la URL del navegador.
      </p>
      <pre><code>import { MemoryRouter, Routes, Route } from &#x27;react-router-dom&#x27;;

function App() {
  return (
    &lt;MemoryRouter initialEntries={[&#x27;/&#x27;]} initialIndex={0}&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;/about&quot; element={&lt;About /&gt;} /&gt;
        &lt;Route path=&quot;/contact&quot; element={&lt;Contact /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/MemoryRouter&gt;
  );
}

// La URL permanece igual: https://example.com/
// Pero internamente el router navega entre rutas</code></pre>

      <h4>Comparación</h4>
      <table>
        <thead>
          <tr>
            <th>Router</th>
            <th>URL</th>
            <th>Requiere configuración de servidor</th>
            <th>Uso principal</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>BrowserRouter</strong></td>
            <td>/about</td>
            <td>Sí</td>
            <td>Aplicaciones web modernas</td>
          </tr>
          <tr>
            <td><strong>HashRouter</strong></td>
            <td>/#/about</td>
            <td>No</td>
            <td>Páginas estáticas, GitHub Pages</td>
          </tr>
          <tr>
            <td><strong>MemoryRouter</strong></td>
            <td>(no cambia)</td>
            <td>No aplica</td>
            <td>Testing, React Native</td>
          </tr>
        </tbody>
      </table>

      <h3 id="instalacion">Instalación</h3>
      <p>
        Para instalar React Router corremos el comando
        <code>pnpm install react-router-dom@latest</code>. Podemos asegurarnos
        que esté todo bien corriendo la aplicación con <code>npm run dev</code>.
      </p>

      <h3 id="rutas-estaticas-hashrouter">Rutas estáticas (HashRouter)</h3>
      <p>
        Podemos colocar rutas estáticas con hash dentro de nuestro documento
        usando el componente HashRouter de React Router. Para esto, dentro de
        nuestro archivo app.jsx colocamos:
      </p>
      <pre><code>// App.jsx
import { HashRouter, Routes, Route } from 'react-router-dom';

function App() {
  return (
    &lt;&gt;
      &lt;HashRouter&gt;
        &lt;Menu /&gt;
        &lt;Routes&gt;
          &lt;Route path=&quot;/&quot; element={&lt;HomePage /&gt;} /&gt;
          &lt;Route path=&quot;/profile&quot; element={&lt;ProfilePage /&gt;} /&gt;
          &lt;Route path=&quot;/blog&quot; element={&lt;BlogPage /&gt;} /&gt;
          &lt;Route
            path=&quot;*&quot;
            element={&lt;h1 className=&quot;text-3xl font-bold&quot;&gt;Not Found&lt;/h1&gt;}
          /&gt;
        &lt;/Routes&gt;
      &lt;/HashRouter&gt;
    &lt;/&gt;
  );
}

export default App;</code></pre>
      <p>
        Dentro de este componente tendremos las páginas/rutas que vamos a
        renderizar dentro del componente Routes, y cada ruta por separado va a
        usar el componente Route. Dicho componente va a tener un atributo path
        que es el hash que va a leer, como también va a tener el atributo
        element que hará referencia a lo que se va a renderizar.
      </p>

      <h3 id="navegacion-navlink">Navegación (NavLink)</h3>
      <p>
        Podemos usar el componente NavLink en vez de la etiqueta a para crear
        links. Este componente nos permite cambiar la URL de la app sin
        necesidad de recargar la página. Así tendremos algo como:
      </p>
      <pre><code>// Menu.jsx
import { NavLink } from 'react-router-dom';

const routes = [
  { to: '/', text: 'Home' },
  { to: '/blog', text: 'Blog' },
  { to: '/profile', text: 'Profile' }
];

function Menu() {
  return (
    &lt;ul&gt;
      {routes.map(route =&gt; (
        &lt;li key={route.to}&gt;
          &lt;NavLink to={route.to} style={({ isActive }) =&gt; ({ color: isActive ? 'red' : 'blue' })}&gt;
            {route.text}
          &lt;/NavLink&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

export default Menu;</code></pre>
      <p>
        Esto nos dará como resultado una lista ul con componentes NavLink
        relacionados a las rutas definidas en la constante routes. Además, si
        estamos ubicados sobre esa opción se va a colocar en rojo.
      </p>

      <h3 id="rutas-dinamicas-useparams">Rutas dinámicas (useParams)</h3>
      <p>
        El slug es una parte de la URL que actúa como un identificador único
        para las páginas o elementos de contenido en una aplicación,
        generalmente al final de la URL como
        platzi.com/clases/como-aprender-react.
      </p>
      <p>
        Gracias al slug podemos cambiar el contenido interno de un componente
        manteniendo la misma estructura. El slug permite al componente entender
        qué datos cargar y cómo consultar el backend para obtener información
        diferente para cada vista.
      </p>
      <p>
        Empezamos creando una lista de publicaciones para un blog. El componente
        base será similar para cada entrada de blog, cambiando solo su contenido
        dependiendo del slug. Este componente se llamará BlogPost y hará uso del
        React hook useParams para este objetivo. Veamos cómo se hace.
      </p>
      <p>
        Primero, creamos un archivo separado para los datos del blog
        (blogData.js) y los exportamos para que puedan ser usados por otros
        componentes:
      </p>
      <pre><code>// blogData.js
export const blogData = [
  {
    title: "¿Qué es React?",
    slug: "que-es-react",
    content: "React es el mejor framework de JavaScript.",
    author: "Juan de Sen"
  },
  {
    title: "¿Qué es Vue?",
    slug: "que-es-vue",
    content: "Vue es un framework progresivo.",
    author: "Otro autor"
  }
];</code></pre>
      <p>
        Después creamos el componente BlogPage que va a mostrar una lista con
        los distintos posts para leer. Importamos los datos desde blogData.js y
        en la prop <code>to</code> del componente Link es donde vamos a colocar
        la parte dinámica:
      </p>
      <pre><code>// BlogPage.jsx
import { Link } from 'react-router-dom';
import { blogData } from './blogData';

const BlogPage = () => {
  return (
    &lt;ul&gt;
      {blogData.map(post =&gt; (
        &lt;li key={post.slug}&gt;
          &lt;Link to={`/blog/${post.slug}`}&gt;{post.title}&lt;/Link&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};

export default BlogPage;</code></pre>
      <p>
        Después en nuestro archivo app.jsx definimos qué se va a renderizar
        cuando entremos a esa ruta dinámica. En este caso vamos a renderizar un
        componente llamado BlogPost:
      </p>
      <pre><code>// App.jsx
import { HashRouter, Routes, Route } from 'react-router-dom';
import BlogPage from './BlogPage';
import BlogPost from './BlogPost';

function App() {
  return (
    &lt;HashRouter&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/blog&quot; element={&lt;BlogPage /&gt;} /&gt;
        &lt;Route path=&quot;/blog/:slug&quot; element={&lt;BlogPost /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/HashRouter&gt;
  );
}

export default App;</code></pre>
      <p>
        Por último, creamos el componente BlogPost que va a tener la estructura
        de los blogs pero cuya información va a variar dependiendo del post.
        Importamos blogData y useParams, y agregamos un manejo de error por si
        el slug no existe:
      </p>
      <pre><code>// BlogPost.jsx
import { useParams } from 'react-router-dom';
import { blogData } from './blogData';

const BlogPost = () => {
  const { slug } = useParams(); // Obtiene el slug desde la URL

  // Lógica para obtener el post correcto basado en el slug
  const post = blogData.find(post =&gt; post.slug === slug);

  // Manejo de error si no se encuentra el post
  if (!post) {
    return &lt;h2&gt;Post no encontrado&lt;/h2&gt;;
  }

  return (
    &lt;div&gt;
      &lt;h2&gt;{post.title}&lt;/h2&gt;
      &lt;p&gt;{post.content}&lt;/p&gt;
      &lt;p&gt;{post.author}&lt;/p&gt;
    &lt;/div&gt;
  );
};

export default BlogPost;</code></pre>

      <h3 id="rutas-anidadas-outlet">Rutas anidadas (Outlet)</h3>
      <p>
        <strong>Nota:</strong> Esta sección muestra un enfoque diferente al
        anterior. En la sección de "Rutas dinámicas" vimos cómo crear páginas
        completamente separadas: cuando navegas a
        <code>/blog/que-es-react</code>, solo ves el contenido del BlogPost. Con
        rutas anidadas, el BlogPost se renderiza
        <strong>dentro de</strong> BlogPage, manteniendo visible el título y la
        lista de posts. Usa rutas anidadas cuando quieras mantener un layout
        persistente.
      </p>
      <p>
        Las Nested Routes (rutas anidadas), como su nombre lo indica, son rutas
        anidadas dentro de otras. Esto permite tener una ruta principal que
        mantiene su contenido visible mientras se navega por subrutas. Por
        ejemplo, una página de blog que mantiene su título y menú mientras
        muestra diferentes posts.
      </p>
      <p>
        El componente <code>Outlet</code> actúa como un marcador de posición
        donde se renderizarán las rutas hijas anidadas.
      </p>
      <p>
        Dentro del archivo app.jsx vamos a encapsular las rutas dinámicas de los
        posts dentro de la ruta de BlogPage:
      </p>
      <pre><code>// App.jsx
import { HashRouter, Routes, Route } from 'react-router-dom';
import BlogPage from './BlogPage';
import BlogPost from './BlogPost';

function App() {
  return (
    &lt;HashRouter&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/blog&quot; element={&lt;BlogPage /&gt;}&gt;
          &lt;Route index element={&lt;p&gt;Selecciona un post para leer&lt;/p&gt;} /&gt;
          &lt;Route path=&quot;:slug&quot; element={&lt;BlogPost /&gt;} /&gt;
        &lt;/Route&gt;
      &lt;/Routes&gt;
    &lt;/HashRouter&gt;
  );
}

export default App;</code></pre>
      <p>
        <strong>Importante:</strong> Nota que el path de la ruta hija es
        <code>":slug"</code> (sin el prefijo <code>/blog</code>). En rutas
        anidadas, los paths son <strong>relativos al padre</strong>. Como ya
        estamos dentro de <code>path="/blog"</code>, la ruta completa será
        automáticamente <code>/blog/:slug</code>.
      </p>
      <p>
        La ruta con <code>index</code> se renderiza cuando estás exactamente en
        <code>/blog</code> (sin ningún slug). Esto muestra un mensaje mientras
        el usuario selecciona un post, en lugar de dejar el Outlet vacío.
      </p>
      <p>
        Después dentro del componente BlogPage.jsx agregamos el componente
        Outlet, que es donde se renderizarán las rutas hijas:
      </p>
      <pre><code>// BlogPage.jsx
import { Link, Outlet } from 'react-router-dom';
import { blogData } from './blogData';

function BlogPage() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Blog&lt;/h1&gt;
      &lt;ul&gt;
        {blogData.map(post =&gt; (
          &lt;li key={post.slug}&gt;
            &lt;Link to={post.slug}&gt;{post.title}&lt;/Link&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;Outlet /&gt;
    &lt;/div&gt;
  );
}

export default BlogPage;</code></pre>
      <p>
        Al hacer esto, cuando navegas a una ruta secundaria como
        <code>/blog/que-es-react</code>, el contenido del BlogPost se renderiza
        en el lugar donde está ubicado el Outlet, manteniendo visible el título
        "Blog" y la lista de posts.
      </p>
      <p>
        <strong>Nota:</strong> Los links usan <code>to={post.slug}</code> (sin
        <code>/blog/</code>) porque son relativos a la ruta actual. Como estamos
        dentro de <code>/blog</code>, un link a <code>"que-es-react"</code> se
        resolverá automáticamente como <code>/blog/que-es-react</code>.
      </p>

      <h2 id="autenticacion">Autenticación</h2>
      <hr />
      <p>
        Vamos a crear un sistema de autenticación ficticio para ilustrar cómo se
        podría implementar un flujo de autenticación.
      </p>
      <p>
        Primero creamos las páginas de login y logout que queremos crear. Para
        la página del Login tendremos:
      </p>
      <pre><code>import { useState } from &quot;react&quot;;
import { useAuth } from &quot;../auth/auth.jsx&quot;;

export default function LoginPage() {
  const auth = useAuth();
  const [username, setUsername] = useState(&quot;&quot;);

  function login(event) {
    event.preventDefault();
    auth.login({ username });
  }

  return (
    &lt;&gt;
      &lt;h1 className=&quot;text-3xl font-bold&quot;&gt;Login&lt;/h1&gt;
      &lt;form onSubmit={login} className=&quot;flex flex-col gap-1.5&quot;&gt;
        &lt;label htmlFor=&quot;username&quot;&gt;Escribe tu nombre de usuario&lt;/label&gt;
        &lt;input
          type=&quot;text&quot;
          id=&quot;username&quot;
          value={username}
          onChange={(e) =&gt; setUsername(e.target.value)}
          className=&quot;bg-gray-200 rounded-md&quot;
        /&gt;
        &lt;button type=&quot;submit&quot;&gt;Enviar&lt;/button&gt;
      &lt;/form&gt;
    &lt;/&gt;
  );
}</code></pre>

      <p>Para la página del Logout tendremos:</p>
      <pre><code>import { useAuth } from &quot;../auth/auth.jsx&quot;;

export default function LogoutPage() {
  const auth = useAuth();

  function logout() {
    auth.logout();
  }

  return (
    &lt;&gt;
      &lt;h1 className=&quot;text-3xl font-bold&quot;&gt;Logout&lt;/h1&gt;
      &lt;p&gt;¿Estás seguro de que quieres cerrar sesión?&lt;/p&gt;
      &lt;button onClick={logout}&gt;Cerrar sesión&lt;/button&gt;
    &lt;/&gt;
  );
}</code></pre>

      <p>Tenemos que añadir estas páginas en el HashRouter:</p>
      <pre><code>&lt;Route path=&quot;/login&quot; element={&lt;LoginPage /&gt;} /&gt;
&lt;Route path=&quot;/logout&quot; element={&lt;LogoutPage /&gt;} /&gt;
&lt;Route path=&quot;/profile&quot; element={&lt;ProfilePage /&gt;} /&gt;</code></pre>

      <p>Como también agregarlas al menú:</p>
      <pre><code>const routes = [
  { to: &quot;/&quot;, text: &quot;Home&quot; },
  { to: &quot;/profile&quot;, text: &quot;Profile&quot; },
  { to: &quot;/blog&quot;, text: &quot;Blog&quot; },
  { to: &quot;/login&quot;, text: &quot;Login&quot; },
  { to: &quot;/logout&quot;, text: &quot;Logout&quot; },
];</code></pre>
      <p>
        Después, vamos a querer usar métodos y estados en toda la aplicación,
        por lo que vamos a necesitar un archivo de autenticación que use un
        reactContext y envíe estos valores a través de un provider. Empezemos
        diciéndole a la aplicación que va a usar valores del provider,
        modificamos nuestro archivo app.jsx:
      </p>
      <pre><code>&lt;HashRouter&gt;
  &lt;AuthProvider&gt;
    &lt;Menu /&gt;
    &lt;Routes&gt;
      &lt;Route path=&quot;/&quot; element={&lt;HomePage /&gt;} /&gt;
      {/* ... más rutas ... */}
    &lt;/Routes&gt;
  &lt;/AuthProvider&gt;
&lt;/HashRouter&gt;</code></pre>

      <p>
        Ahora tenemos que crear nuestro archivo auth.jsx que es donde vamos a
        crear el contexto y los valores que va a enviar el provider:
      </p>
      <pre><code>import React from &quot;react&quot;;
import { useNavigate } from &quot;react-router-dom&quot;;

// context
const AuthContext = React.createContext();

// provider
function AuthProvider({ children }) {
  // navigation
  const navigate = useNavigate();

  // state
  const [user, setUser] = React.useState(null);

  // methods
  const login = ({ username }) =&gt; {
    setUser({ username });
    navigate(&quot;/profile&quot;);
  };

  const logout = () =&gt; {
    setUser(null);
    navigate(&quot;/&quot;);
  };

  // values
  const auth = { user, login, logout };

  // send values to provider
  return &lt;AuthContext.Provider value={auth}&gt;{children}&lt;/AuthContext.Provider&gt;;
}

// hook
function useAuth() {
  const auth = React.useContext(AuthContext);
  return auth;
}

export { useAuth, AuthProvider };</code></pre>

      <p>
        Con esto hemos creado un sistema de autenticación básico que nos
        permite: (1) Crear páginas de Login y Logout con formularios
        funcionales, (2) Usar React Context para compartir el estado de
        autenticación en toda la aplicación, (3) Navegar automáticamente a
        diferentes rutas después de hacer login o logout, y (4) Acceder al
        estado del usuario desde cualquier componente usando el hook
        <code>useAuth()</code>. Sin embargo, este sistema aún tiene
        limitaciones: las rutas privadas son accesibles directamente desde la
        URL, no hay persistencia de sesión al recargar la página, y falta manejo
        de roles. En las siguientes secciones veremos cómo resolver estas
        limitaciones.
      </p>

      <h3 id="proteger-rutas-con-autenticacion">
        Proteger rutas con autenticación
      </h3>
      <p>
        Primero tenemos que definir qué rutas serán públicas y cuáles serán
        privadas. Para esto vamos a crear una tercera propiedad en las rutas:
      </p>
      <pre><code>const routes = [
  { to: &quot;/&quot;, text: &quot;Home&quot;, private: false },
  { to: &quot;/profile&quot;, text: &quot;Profile&quot;, private: true },
  { to: &quot;/blog&quot;, text: &quot;Blog&quot;, private: false },
  { to: &quot;/login&quot;, text: &quot;Login&quot;, private: false },
  { to: &quot;/logout&quot;, text: &quot;Logout&quot;, private: true },
];</code></pre>

      <p>
        Después, en nuestro menú donde renderizamos las rutas vamos a usar un
        condicional, tal que si existe un usuario vamos a mostrar la ruta:
      </p>
      <pre><code>export default function Menu() {
  const auth = useAuth();

  return (
    &lt;nav&gt;
      &lt;ul className=&quot;flex flex-row gap-4&quot;&gt;
        {routes.map((route) =&gt; {
          if (route.private &amp;&amp; !auth.user) return null;
          if (route.to === &#x27;/login&#x27; &amp;&amp; auth.user) {
            return null;
          }

          return (
            &lt;li key={route.text}&gt;
              &lt;NavLink
                style={({ isActive }) =&gt; ({
                  color: isActive ? &quot;red&quot; : &quot;blue&quot;,
                })}
                to={route.to}
              &gt;
                {route.text}
              &lt;/NavLink&gt;
            &lt;/li&gt;
          );
        })}
      &lt;/ul&gt;
    &lt;/nav&gt;
  );
}</code></pre>

      <p>
        Con esta implementación hemos logrado ocultar rutas del menú según el
        estado de autenticación del usuario. Agregamos una propiedad
        <code>private</code> a cada ruta para identificar cuáles requieren
        autenticación, y usamos renderizado condicional en el componente Menu
        para mostrar u ocultar enlaces dinámicamente: las rutas privadas
        (Profile, Logout) solo aparecen si hay un usuario autenticado, y el
        enlace de Login desaparece cuando ya iniciaste sesión. Sin embargo, esto
        solo oculta los enlaces del menú; un usuario puede seguir accediendo a
        estas rutas escribiendo la URL directamente en el navegador. Para
        solucionar esto, necesitamos implementar protección de rutas con
        redireccionamiento.
      </p>

      <h3 id="proteccion-de-rutas-con-redireccionamiento">
        Protección de rutas con redireccionamiento
      </h3>
      <p>
        Cuando desarrollamos aplicaciones web, uno de los aspectos más cruciales
        es proteger adecuadamente las rutas. Podemos ocultar rutas del menú,
        pero todavía pueden ser accesibles a través de la URL directa. Siguiendo
        las mejores prácticas de React, es vital garantizar que los usuarios no
        autenticados no puedan acceder a ciertas páginas y que los usuarios
        autenticados no sean redirigidos a páginas de acceso.
      </p>
      <p>
        Implementar rutas protegidas implica involucrar un componente que
        gestione las redirecciones según el estado de autenticación del usuario.
        Crear un componente reutilizable es la mejor estrategia para evitar la
        repetición de código.
      </p>
      <p>Dentro de nuestro archivo auth.jsx vamos a crear el componente:</p>
      <pre><code>const AuthRoute = ({ children }) =&gt; {
  const auth = useAuth();

  if (!auth.user) {
    return &lt;Navigate to=&quot;/login&quot; /&gt;;
  }

  return children;
};</code></pre>

      <p>
        Después, en nuestro archivo app.jsx protegemos las rutas privadas usando
        el componente:
      </p>
      <pre><code>&lt;Route
  path=&quot;/logout&quot;
  element={
    &lt;AuthRoute&gt;
      &lt;LogoutPage /&gt;
    &lt;/AuthRoute&gt;
  }
/&gt;

&lt;Route
  path=&quot;/profile&quot;
  element={
    &lt;AuthRoute&gt;
      &lt;ProfilePage /&gt;
    &lt;/AuthRoute&gt;
  }
/&gt;</code></pre>

      <p>
        Por último, si ya iniciamos sesión no deberíamos poder ir de nuevo a la
        página de login, por lo que en el archivo LoginPage agregamos:
      </p>
      <pre><code>if (auth.user) {
  return &lt;p&gt;Ya has iniciado sesión como {auth.user.username}&lt;/p&gt;;
}</code></pre>

      <p>
        Para que nos regrese ese mensaje y no el formulario para hacer login.
      </p>

      <p>
        Con esta implementación hemos resuelto el problema de seguridad crítico
        de la sección anterior. Creamos el componente <code>AuthRoute</code> que
        actúa como guardián de las rutas privadas: verifica si existe un usuario
        autenticado y, en caso contrario, redirige automáticamente a la página
        de login usando <code>Navigate</code>. Envolvimos las rutas sensibles
        (Profile, Logout) con este componente, garantizando que aunque alguien
        intente acceder directamente por URL, será redirigido. Además, agregamos
        protección bidireccional en LoginPage para evitar que usuarios ya
        autenticados vean el formulario de login innecesariamente. Ahora nuestro
        sistema de autenticación es robusto y seguro. En la siguiente sección
        veremos cómo extenderlo para manejar diferentes niveles de acceso
        mediante roles.
      </p>

      <h3 id="roles-y-autorizacion">Roles y autorización</h3>
      <p>Empezamos creando una lista de administradores:</p>
      <pre><code>export const adminList = [&quot;admin1&quot;, &quot;admin2&quot;, &quot;admin3&quot;];</code></pre>

      <p>
        Y cuando hacemos login, ya no solo mandamos el username, sino que
        también verificamos si es admin o no:
      </p>
      <pre><code>const login = ({ username }) =&gt; {
  const isAdmin = adminList.includes(username);
  setUser({ username, isAdmin });
  navigate(&quot;/profile&quot;);
};</code></pre>

      <p>
        Ahora podemos agregar una funcionalidad para los admins, como eliminar
        un blog. Para esto en nuestro archivo BlogPost.jsx agregamos:
      </p>
      <pre><code>export default function BlogPost() {
  const auth = useAuth();
  const { slug } = useParams();
  const post = blogData.find((post) =&gt; post.slug === slug);

  return (
    &lt;div&gt;
      &lt;h2&gt;{post.title}&lt;/h2&gt;
      &lt;p&gt;{post.content}&lt;/p&gt;
      &lt;p&gt;{post.author}&lt;/p&gt;
      {auth.user?.isAdmin &amp;&amp; &lt;button&gt;Eliminar Post&lt;/button&gt;}
    &lt;/div&gt;
  );
}</code></pre>
    </main>
  </body>
</html>
