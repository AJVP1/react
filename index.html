<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="styles.css" />
    <title>React</title>
  </head>
  <body>
    <!-- navegacion -->
    <nav>
      <h2>Indice</h2>
    </nav>

    <!-- contenido principal -->
    <main>
      <h1>React</h1>
      <h2 id="introduccion">Introduccion</h2>
      <hr />

      <p>
        React es una librería de JavaScript orientada a la construcción de
        interfaces de usuario mediante un modelo declarativo basado en
        componentes. En React, la interfaz se define como una función del estado
        de la aplicación: cada vez que el estado cambia, React recalcula la
        representación de la UI y aplica al DOM real únicamente las diferencias
        necesarias.
      </p>

      <p>
        Para lograr esto, React utiliza una estructura interna conocida como
        Virtual DOM, que mantiene una representación en memoria del árbol de
        componentes. Mediante un proceso de reconciliation, React compara el
        árbol anterior con el nuevo y ejecuta actualizaciones mínimas sobre el
        DOM del navegador, optimizando el rendimiento.
      </p>

      <p>
        React implementa un flujo de datos unidireccional (one-way data
        binding), donde los cambios de estado se propagan desde componentes
        padres hacia hijos a través de props. Esta arquitectura favorece la
        previsibilidad del comportamiento de la aplicación y simplifica el
        razonamiento sobre el estado.
      </p>

      <p>
        Aunque React puede utilizarse para desarrollar Single Page Applications
        (SPA), no impone una arquitectura completa de aplicación.
        Funcionalidades como ruteo, gestión global del estado, manejo de efectos
        laterales y persistencia se integran mediante herramientas del
        ecosistema (por ejemplo, React Router, Context, Redux, entre otras).
      </p>

      <h2 id="empezar-un-proyecto">Empezar un proyecto</h2>
      <hr />
      <p>
        Para empezar a desarrollar nuestro frontend con react tenemos que estar
        parados en el root de nuestro proyecto y corremos el comando
        <code>pnpm create vite@latest</code> aquí seleccionamos las
        configuraciones para trabajar con react y esto nos creara la carpeta
        para el frontend.
      </p>

      <p>
        Esta carpeta viene con las configuraciones para usar react como
        node_modules, public, src, … etc. Y donde una vez tengamos listo el
        frontend para produccion corremos el comando npm run build.
      </p>
      <p>
        Dentro de src nos crea la carpeta de assets para las imágenes y 4
        archivos más, dos de estos archivo (main.jsx y index.css) son los
        principales, el archivo jsx es el que va a manejar toda la parte de
        renderizado en el DOM y el css es el que va a tener los estilos
        principales. Por otro lado, los archivos (app.css y app.jsx) son los
        archivos secundarios con una muestra de un componente de react en el
        archivo jsx, y los estilos del mismo en el archivo css.
      </p>
      <pre><code>function App() {
  const items = [&quot;react&quot;, &quot;javascript&quot;, &quot;git&quot;];
  return (
    &lt;section&gt;
      &lt;h1&gt;Hola mundo&lt;/h1&gt;
      &lt;ul&gt;
        {items.map((item, index) =&gt; (
          &lt;li key={index}&gt;{item}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/section&gt;
  );
}</code></pre>
      <p>
        En este ejemplo, usamos map() para renderizar una lista de elementos de
        forma declarativa, sin manipular el DOM manualmente.
      </p>
      <p>Las ventajas de este enfoque son evidentes:</p>
      <ul>
        <li>Código más declarativo y legible</li>
        <li>No es necesario manipular el DOM directamente</li>
        <li>Menos líneas de código para lograr el mismo resultado</li>
        <li>Mayor facilidad para mantener y actualizar</li>
      </ul>

      <h3 id="tailwind-en-react-con-vite">
        <em>Tailwind en react con vite</em>
      </h3>
      <p>
        Existen dos formas de instalar Tailwind CSS en un proyecto de React con
        Vite: la versión 3 (estándar y más utilizada) y la versión 4 (más nueva
        y simplificada).
      </p>

      <h4>Tailwind CSS v3 (Instalación estándar)</h4>
      <p>
        Esta es la forma más común y estable. Primero instalamos las
        dependencias necesarias:
      </p>
      <pre><code>pnpm install -D tailwindcss postcss autoprefixer
pnpm dlx tailwindcss init -p</code></pre>
      <p>
        Esto creará dos archivos: <code>tailwind.config.js</code> y
        <code>postcss.config.js</code>. Configuramos el
        <code>tailwind.config.js</code> para indicar dónde están nuestros
        archivos:
      </p>
      <pre><code>export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}</code></pre>
      <p>
        Luego, en el archivo <code>src/index.css</code> agregamos las directivas
        de Tailwind:
      </p>
      <pre><code>@tailwind base;
@tailwind components;
@tailwind utilities;</code></pre>
      <p>
        Y listo, ya podemos empezar a usar tailwind dentro de nuestros
        componentes en react.
      </p>

      <h4>Tailwind CSS v4 (Nueva versión simplificada)</h4>
      <p>
        La versión 4 simplifica el proceso de instalación. Instalamos tailwind
        con:
      </p>
      <pre><code>pnpm install -D tailwindcss @tailwindcss/vite</code></pre>
      <p>
        Después lo agregamos a la configuración en
        <code>vite.config.js</code>:
      </p>
      <pre><code>import { defineConfig } from 'vite';
import tailwindcss from '@tailwindcss/vite';

export default defineConfig({
  plugins: [
    tailwindcss(),
  ],
});</code></pre>
      <p>
        Y en el archivo <code>src/index.css</code> simplemente importamos
        tailwind:
      </p>
      <pre><code>@import "tailwindcss";</code></pre>
      <p>
        Con cualquiera de las dos versiones ya podemos usar las clases de
        Tailwind en nuestros componentes como si fuera HTML común.
      </p>

      <h2 id="componentes">Componentes</h2>
      <hr />
      <p>
        React simplifica el desarrollo de aplicaciones web al dejarnos hacer
        código en componentes reusables. Un componente en React es una función
        que devuelve algo que queremos que se muestre en la pantalla. Usualmente
        dichas funciones se crean como arrow functions para hacerlas más
        sencillas, aunque de igual manera está bien. Típicamente los componentes
        comienzan con una letra mayuscula para distinguirlos de las etiquetas de
        HTML, veamos un ejemplo
      </p>
      <pre><code>const MyComponent = () =&gt; { return "I'm a component"};</code></pre>
      <p>
        En React, los componentes no solo pueden devolver texto plano, también
        pueden devolver HTML. Por ejemplo
      </p>
      <pre><code>const Bienvenida = () =&gt; {
  return &lt;h1&gt;Hola, mundo&lt;/h1&gt;
};</code></pre>
      <p>
        A esto se le conoce como JSX, que parece HTML pero no lo es. Es una
        sintaxis especial que React usa para escribir código como HTML dentro de
        JavaScript.
      </p>
      <p>
        Para usar un componente dentro de otro, simplemente lo llamamos como si
        fuera una etiqueta HTML. Por ejemplo
      </p>
      <pre><code>const App = () =&gt; {
  return (
    &lt;section&gt;
      &lt;Bienvenida /&gt;
    &lt;/section&gt;
  );
};</code></pre>
      <p>
        Esto hace que el componente Bienvenida se renderice dentro del
        componente App.
      </p>

      <h3 id="props"><em>Props</em></h3>
      <p>
        Las props (abreviatura de &quot;properties&quot; o propiedades) son el
        mecanismo que React utiliza para pasar datos de un componente padre a un
        componente hijo. Funcionan como parámetros que permiten personalizar los
        componentes y hacerlos verdaderamente reutilizables. Por ejemplo
      </p>
      <pre><code>const Card = ({ title, content }) =&gt; {
  return (
    &lt;div&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;p&gt;{content}&lt;/p&gt;
    &lt;/div&gt;
  );
};

export default Card;</code></pre>

      <p>
        En este ejemplo creamos un componente, usamos las propiedades title y
        content, y exportamos el componente.
      </p>
      <p>
        Para usar el componente lo usamos como si fuera una etiqueta html y
        definiendo en los atributos el contenido de las propiedades.
      </p>
      <pre><code >import Card from &quot;./components/Card&quot;;

function App() {
  return (
    &lt;section&gt;
      &lt;Card title=&quot;Cart uno&quot; content=&quot;Esta es una descripción&quot; /&gt;
    &lt;/section&gt;
  );
}

export default App;</code></pre>
      <p>
        Aquí importamos el componente Card y lo usamos dentro del componente
        App, pasando valores específicos para las props title y content.
      </p>

      <h3 id="estados-usestate"><em>Estados (useState) </em></h3>
      <p>
        El estado en React es un mecanismo para almacenar información que puede
        cambiar durante el ciclo de vida de un componente. Podemos visualizarlo
        como cajas de almacenamiento donde guardamos datos específicos que
        nuestros componentes necesitan para funcionar correctamente.
      </p>
      <p>Existen dos tipos principales de estados:</p>

      <ul>
        <li>
          Estado local: Información almacenada a nivel de componente, accesible
          solo dentro del componente donde se define.
        </li>
        <li>
          Estado global: Información compartida entre múltiples componentes de
          la aplicación.
        </li>
      </ul>

      <p>
        React proporciona una herramienta especial llamada useState, que es un
        hook que nos permite implementar estados locales en nuestros componentes
        funcionales. Este hook nos devuelve:
      </p>

      <ul>
        <li>Una variable para leer el valor actual del estado</li>
        <li>Una función para actualizar ese valor</li>
        <li>El valor inicial del estado</li>
      </ul>

      <p>La sintaxis básica es</p>
      <pre><code>const [valor, setValor] = useState(valorInicial);</code></pre>

      <p>
        donde <code>valor</code> es la variable que contiene el estado actual,
        <code>setValor</code> es la función que nos permite actualizar ese
        estado y <code>valorInicial</code> es el valor que con el que comienza
        el estado.
      </p>

      <p>Ejemplo</p>
      <pre><code>import { useState } from 'react';

const Counter = () =&gt; {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;h2&gt;El contador está en: {count}&lt;/h2&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Incrementar&lt;/button&gt;
      &lt;button onClick={() =&gt; setCount(count - 1)}&gt;Decrementar&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
      <p>
        Los estados locales son extremadamente versátiles y pueden utilizarse en
        numerosos escenarios:
      </p>
      <ul>
        <li>
          Formularios: Para almacenar los valores de los campos mientras el
          usuario los completa
        </li>
        <li>
          Toggles: Para manejar estados de activado/desactivado (como menús
          desplegables)
        </li>
        <li>
          Filtros: Para almacenar criterios de filtrado en listas o colecciones
        </li>
        <li>Paginación: Para mantener el número de página actual</li>
        <li>
          Cargas de datos: Para indicar si los datos están cargando, se han
          cargado correctamente o ha ocurrido un error
        </li>
      </ul>

      <h4>Ejemplo de toggle button</h4>
      <pre><code>import { useState } from 'react';

const ToggleButton = () =&gt; {
  const [isActive, setIsActive] = useState(false);

  return (
    &lt;button onClick={() =&gt; setIsActive(!isActive)}&gt;
      {isActive ? &#x27;Activo&#x27; : &#x27;Inactivo&#x27;}
    &lt;/button&gt;
  );
};</code></pre>

      <h4>Ejemplo de variable en formulario</h4>
      <pre><code>import { useState } from 'react';

const NameForm = () =&gt; {
  const [name, setName] = useState(&#x27;&#x27;);

  return (
    &lt;div&gt;
      &lt;input
        type=&quot;text&quot;
        value={name}
        placeholder=&quot;Ingresa tu nombre&quot;
        onChange={(event) =&gt; setName(event.target.value)}
      /&gt;
      &lt;p&gt;Hola, {name ? name : &#x27;visitante&#x27;}&lt;/p&gt;
    &lt;/div&gt;
  );
};</code></pre>

      <h4 id="multiples-estados-en-un-componente">
        Múltiples estados en un componente
      </h4>
      <p>
        En la mayoría de los casos, un componente necesita más de una variable
        de estado. Podemos utilizar múltiples llamadas a useState dentro del
        mismo componente:
      </p>
      <pre><code>import { useState } from 'react';

const UserProfile = () =&gt; {
  const [name, setName] = useState(&#x27;&#x27;);
  const [email, setEmail] = useState(&#x27;&#x27;);
  const [age, setAge] = useState(0);

  return (
    &lt;div&gt;
      &lt;input
        type=&quot;text&quot;
        placeholder=&quot;Nombre&quot;
        value={name}
        onChange={(e) =&gt; setName(e.target.value)}
      /&gt;
      &lt;input
        type=&quot;email&quot;
        placeholder=&quot;Email&quot;
        value={email}
        onChange={(e) =&gt; setEmail(e.target.value)}
      /&gt;
      &lt;input
        type=&quot;number&quot;
        placeholder=&quot;Edad&quot;
        value={age}
        onChange={(e) =&gt; setAge(Number(e.target.value))}
      /&gt;
      &lt;p&gt;Perfil: {name} ({age} años) - {email}&lt;/p&gt;
    &lt;/div&gt;
  );
};</code></pre>
      <h4 id="actualizacion-basada-en-el-estado-anterior">
        Actualización basada en el estado anterior
      </h4>
      <p>
        A veces necesitamos actualizar el estado basándonos en su valor
        anterior. En lugar de pasar un valor directamente, podemos pasar una
        función que recibe el estado anterior y retorna el nuevo estado:
      </p>
      <pre><code>import { useState } from 'react';

const CounterAdvanced = () =&gt; {
  const [count, setCount] = useState(0);

  // Forma correcta: pasar una función
  const increment = () =&gt; {
    setCount((prevCount) =&gt; prevCount + 1);
  };

  const decrement = () =&gt; {
    setCount((prevCount) =&gt; prevCount - 1);
  };

  const reset = () =&gt; {
    setCount(0);
  };

  return (
    &lt;div&gt;
      &lt;p&gt;Contador: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;Incrementar&lt;/button&gt;
      &lt;button onClick={decrement}&gt;Decrementar&lt;/button&gt;
      &lt;button onClick={reset}&gt;Reiniciar&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
      <p>
        Esta forma de actualizar es especialmente importante cuando realizas
        múltiples actualizaciones del estado en rápida sucesión o cuando la
        actualización depende del estado anterior. React agrupa las
        actualizaciones (batching) para optimizar el rendimiento, por lo que
        siempre es recomendable usar la función callback cuando el nuevo estado
        depende del anterior.
      </p>

      <h3 id="efectos-secundarios-useeffect">
        <em>Efectos secundarios (useEffect)</em>
      </h3>
      <p>
        Los efectos secundarios son operaciones que ocurren fuera del flujo
        principal de renderizado de React. Estos incluyen:
      </p>
      <ul>
        <li>Llamadas a APIs externas</li>
        <li>Suscripciones a eventos</li>
        <li>Manipulación del DOM</li>
        <li>Temporizadores (setTimeout, setInterval)</li>
        <li>Almacenamiento en localStorage</li>
      </ul>
      <p>
        El hook useEffect fue diseñado específicamente para manejar estos
        efectos secundarios, permitiéndonos ejecutar código después de que el
        componente se haya renderizado en la pantalla.
      </p>
      <p>El hook useEffect recibe dos parámetros:</p>
      <ul>
        <li>Una función que contiene el código a ejecutar</li>
        <li>
          Un array de dependencias (opcional) que determina cuándo se ejecutará
          el efecto
        </li>
      </ul>
      <pre><code>useEffect(() =&gt; {}, [dependencias]);</code></pre>
      <p>
        Si el array de dependencias está vacío [], el efecto se ejecutará solo
        una vez después del primer renderizado. Si incluimos variables en el
        array, el efecto se ejecutará cada vez que alguna de esas variables
        cambie de valor.
      </p>
      <p>Ejemplo básico con dependencias:</p>
      <pre><code>import { useState, useEffect } from 'react';

const CounterWithEffect = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log(`El contador cambió a ${count}`);
  }, [count]);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Incrementar&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
      <p>
        El hook useEffect es extremadamente versátil y puede utilizarse en
        numerosos escenarios:
      </p>
      <ul>
        <li>
          Obtención de datos: Realizar peticiones a APIs cuando un componente se
          monta o cuando cambian ciertos parámetros
        </li>
        <li>
          Suscripciones: Establecer listeners de eventos y limpiarlos cuando el
          componente se desmonta
        </li>
        <li>
          Manipulación del DOM: Actualizar el título de la página o interactuar
          con elementos del DOM
        </li>
        <li>
          Animaciones: Iniciar o detener animaciones basadas en cambios de
          estado
        </li>
        <li>
          Persistencia de datos: Guardar información en localStorage cuando
          cambian ciertos valores
        </li>
      </ul>

      <h4 id="funcion-cleanup-useeffect">Función cleanup en useEffect</h4>
      <p>
        Cuando necesitamos limpiar recursos (suscripciones, timers, listeners),
        podemos retornar una función desde useEffect que se ejecutará al
        desmontar el componente o antes de ejecutar el efecto nuevamente:
      </p>
      <pre><code>import { useState, useEffect } from 'react';

const SubscriptionExample = () =&gt; {
  const [isSubscribed, setIsSubscribed] = useState(false);

  useEffect(() =&gt; {
    // Setup: ejecuta cuando el componente monta
    if (isSubscribed) {
      console.log('Suscrito a eventos');
      const handleEvent = () =&gt; console.log('Evento disparado');
      window.addEventListener('scroll', handleEvent);

      // Cleanup: se ejecuta antes de desmontar o antes del siguiente efecto
      return () =&gt; {
        console.log('Desuscrito de eventos');
        window.removeEventListener('scroll', handleEvent);
      };
    }
  }, [isSubscribed]);

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setIsSubscribed(!isSubscribed)}&gt;
        {isSubscribed ? 'Desuscribirse' : 'Suscribirse'}
      &lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>

      <h4 id="useeffect-sin-dependencias-monta-y-desmonta">
        useEffect sin dependencias (monta y desmonta)
      </h4>
      <pre><code>import { useState, useEffect } from 'react';

const TimerExample = () =&gt; {
  const [seconds, setSeconds] = useState(0);

  useEffect(() =&gt; {
    // Corre una sola vez cuando el componente monta
    const interval = setInterval(() =&gt; {
      setSeconds((prev) =&gt; prev + 1);
    }, 1000);

    // Cleanup: se ejecuta cuando el componente desmonta
    return () =&gt; clearInterval(interval);
  }, []); // Array vacío = solo al montar/desmontar

  return &lt;p&gt;Tiempo: {seconds} segundos&lt;/p&gt;;
};</code></pre>

      <h4 id="useeffect-para-obtener-datos">useEffect para obtener datos</h4>
      <pre><code>import { useState, useEffect } from 'react';

const DataFetcher = ({ userId }) =&gt; {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    // Reset states
    setLoading(true);
    setError(null);

    // Fetch de datos
    fetch(`https://api.example.com/users/${userId}`)
      .then((response) =&gt; {
        if (!response.ok) throw new Error('Error en la API');
        return response.json();
      })
      .then((data) =&gt; setUser(data))
      .catch((err) =&gt; setError(err.message))
      .finally(() =&gt; setLoading(false));
  }, [userId]); // Se ejecuta cada vez que userId cambia

  if (loading) return &lt;p&gt;Cargando...&lt;/p&gt;;
  if (error) return &lt;p&gt;Error: {error}&lt;/p&gt;;
  return &lt;div&gt;&lt;h2&gt;{user?.name}&lt;/h2&gt;&lt;/div&gt;;
};</code></pre>
      <p>
        <strong>Importante:</strong> La función cleanup retornada desde
        useEffect es esencial para evitar memory leaks. Siempre limpia
        listeners, timers, o suscripciones que hayas establecido en el efecto.
      </p>

      <h3 id="estados-complejos-usereducer">
        <em>Estados complejos (useReducer)</em>
      </h3>
      <p>
        A diferencia de useState, que simplemente reemplaza el estado anterior,
        useReducer permite definir una función reductora (reducer) que
        especifica cómo el estado debe cambiar en respuesta a diferentes
        acciones. Esta estructura se asemeja al patrón de diseño Redux, pero
        integrado directamente en React.
      </p>
      <p>La sintaxis básica de useReducer incluye:</p>
      <pre><code>const [state, dispatch] = useReducer(reducer, initialState);</code></pre>
      <p>
        Donde <code>state</code> es el estado actual, <code>dispatch</code> es
        una función para enviar acciones al reducer, <code>reducer</code> es una
        función que determina cómo actualizar el estado basado en la acción, e
        <code>initialState</code> es el valor inicial.
      </p>
      <h4 id="cuando-usar-usereducer">
        ¿Cuándo usar useReducer en lugar de useState?
      </h4>
      <p>Usa useReducer cuando:</p>
      <ul>
        <li>El estado tiene múltiples valores relacionados entre sí</li>
        <li>
          La lógica de actualización es compleja o tiene muchas condiciones
        </li>
        <li>
          El siguiente estado depende del estado anterior de forma compleja
        </li>
        <li>
          Quieres optimizar el rendimiento en componentes grandes (dispatch no
          cambia entre renders)
        </li>
        <li>Necesitas una lógica de estado más predecible y testeable</li>
      </ul>
      <p>Usa useState cuando:</p>
      <ul>
        <li>El estado es un valor simple (string, number, boolean)</li>
        <li>Las actualizaciones son directas y simples</li>
        <li>No hay mucha lógica condicional en las actualizaciones</li>
      </ul>

      <h4 id="ejemplo-basico-contador">Ejemplo básico: Contador</h4>
      <p>
        Empezamos definiendo la función reducer, esta recibirá dos argumentos,
        el primero es el estado y el segundo es la acción.
      </p>
      <pre><code>import { useReducer } from &#x27;react&#x27;;

// Función reducer
const reducer = (state, action) =&gt; {
  // definimos acciones según el tipo de acción
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    case "reset":
      return { count: 0 };
    default:
      return state;
  }
};

// Componente
const Counter = () =&gt; {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    &lt;div&gt;
      &lt;p&gt;Contador: {state.count}&lt;/p&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#x27;increment&#x27; })}&gt;
        Incrementar
      &lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#x27;decrement&#x27; })}&gt;
        Decrementar
      &lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#x27;reset&#x27; })}&gt;
        Reiniciar
      &lt;/button&gt;
    &lt;/div&gt;
  );
};

export default Counter;</code></pre>

      <h4 id="ejemplo-con-payload-carrito-de-compras">
        Ejemplo con payload: Carrito de compras
      </h4>
      <p>
        Las acciones pueden incluir datos adicionales (payload) para actualizar
        el estado. Veamos un ejemplo más complejo con un carrito de compras:
      </p>
      <pre><code>import { useReducer } from &#x27;react&#x27;;

// Mejores prácticas: usar constantes para los tipos de acción
const ACTIONS = {
  ADD_ITEM: &#x27;add_item&#x27;,
  REMOVE_ITEM: &#x27;remove_item&#x27;,
  UPDATE_QUANTITY: &#x27;update_quantity&#x27;,
  CLEAR_CART: &#x27;clear_cart&#x27;
};

// Reducer con lógica compleja
const cartReducer = (state, action) =&gt; {
  switch (action.type) {
    case ACTIONS.ADD_ITEM: {
      const existingItem = state.items.find(
        item =&gt; item.id === action.payload.id
      );

      if (existingItem) {
        return {
          ...state,
          items: state.items.map(item =&gt;
            item.id === action.payload.id
              ? { ...item, quantity: item.quantity + 1 }
              : item
          )
        };
      }

      return {
        ...state,
        items: [...state.items, { ...action.payload, quantity: 1 }]
      };
    }

    case ACTIONS.REMOVE_ITEM:
      return {
        ...state,
        items: state.items.filter(item =&gt; item.id !== action.payload.id)
      };

    case ACTIONS.UPDATE_QUANTITY:
      return {
        ...state,
        items: state.items.map(item =&gt;
          item.id === action.payload.id
            ? { ...item, quantity: action.payload.quantity }
            : item
        )
      };

    case ACTIONS.CLEAR_CART:
      return { items: [] };

    default:
      return state;
  }
};

// Componente del carrito
const ShoppingCart = () =&gt; {
  const [state, dispatch] = useReducer(cartReducer, { items: [] });

  const addItem = (item) =&gt; {
    dispatch({ type: ACTIONS.ADD_ITEM, payload: item });
  };

  const removeItem = (id) =&gt; {
    dispatch({ type: ACTIONS.REMOVE_ITEM, payload: { id } });
  };

  const updateQuantity = (id, quantity) =&gt; {
    dispatch({
      type: ACTIONS.UPDATE_QUANTITY,
      payload: { id, quantity }
    });
  };

  const clearCart = () =&gt; {
    dispatch({ type: ACTIONS.CLEAR_CART });
  };

  const total = state.items.reduce(
    (sum, item) =&gt; sum + item.price * item.quantity,
    0
  );

  return (
    &lt;div&gt;
      &lt;h2&gt;Carrito de Compras&lt;/h2&gt;
      &lt;ul&gt;
        {state.items.map(item =&gt; (
          &lt;li key={item.id}&gt;
            {item.name} - ${item.price} x {item.quantity}
            &lt;button onClick={() =&gt; updateQuantity(item.id, item.quantity + 1)}&gt;
              +
            &lt;/button&gt;
            &lt;button onClick={() =&gt; updateQuantity(item.id, item.quantity - 1)}&gt;
              -
            &lt;/button&gt;
            &lt;button onClick={() =&gt; removeItem(item.id)}&gt;
              Eliminar
            &lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;p&gt;Total: ${total.toFixed(2)}&lt;/p&gt;
      &lt;button onClick={() =&gt; addItem({ id: 1, name: &#x27;Producto 1&#x27;, price: 10 })}&gt;
        Agregar Producto 1
      &lt;/button&gt;
      &lt;button onClick={clearCart}&gt;Limpiar Carrito&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default ShoppingCart;</code></pre>

      <h4 id="mejores-practicas-usereducer">
        Mejores prácticas con useReducer
      </h4>
      <ul>
        <li>
          Usa constantes para los tipos de acción: Evita errores de tipeo y
          facilita el refactoring
        </li>
        <li>
          El reducer debe ser puro: No debe tener efectos secundarios ni
          mutaciones directas
        </li>
        <li>
          Retorna siempre un nuevo objeto: Usa el spread operator (...) para
          crear nuevos objetos en lugar de modificar el estado directamente
        </li>
        <li>
          Incluye un caso default: Siempre retorna el estado actual si la acción
          no coincide
        </li>
        <li>
          Usa payload para datos adicionales: Envía información adicional en la
          propiedad payload de la acción
        </li>
      </ul>

      <h2 id="fetch">Fetch</h2>
      <hr />
      <p>
        Fetch es la API nativa de JavaScript para realizar peticiones HTTP a
        servidores externos. En React, estas peticiones se realizan típicamente
        dentro de useEffect, ya que son efectos secundarios que deben ejecutarse
        después del renderizado inicial del componente.
      </p>
      <p>
        La combinación de useState para almacenar los datos y useEffect para
        obtenerlos es el patrón fundamental para trabajar con APIs en React.
      </p>

      <h3 id="ejemplo-basico-then">Ejemplo básico con .then()</h3>
      <p>Un llamado simple a una API se vería así:</p>
      <pre><code>import { useState, useEffect } from &#x27;react&#x27;;

const UserList = () =&gt; {
  // Estado para almacenar los usuarios
  const [users, setUsers] = useState([]);

  useEffect(() =&gt; {
    // Realizamos la petición HTTP
    fetch(&#x27;https://jsonplaceholder.typicode.com/users&#x27;)
      // Convertimos la respuesta a JSON
      .then(response =&gt; response.json())
      // Guardamos los datos en el estado
      .then(data =&gt; setUsers(data))
      // Manejamos errores básicos
      .catch(error =&gt; console.error(&#x27;Error fetching data:&#x27;, error));
  }, []); // Array vacío = solo se ejecuta al montar

  // Renderizamos la lista
  return (
    &lt;div&gt;
      &lt;h1&gt;Usuarios&lt;/h1&gt;
      &lt;ul&gt;
        {users.map(user =&gt; (
          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};

export default UserList;</code></pre>

      <h3 id="ejemplo-moderno-async-await">Ejemplo moderno con async/await</h3>
      <p>
        La sintaxis moderna con async/await es más legible y fácil de mantener.
        Sin embargo, como useEffect no puede ser directamente async, debemos
        crear una función interna:
      </p>
      <pre><code>import { useState, useEffect } from &#x27;react&#x27;;

const UserList = () =&gt; {
  const [users, setUsers] = useState([]);

  useEffect(() =&gt; {
    // Función async dentro de useEffect
    const fetchUsers = async () =&gt; {
      try {
        const response = await fetch(&#x27;https://jsonplaceholder.typicode.com/users&#x27;);
        const data = await response.json();
        setUsers(data);
      } catch (error) {
        console.error(&#x27;Error fetching data:&#x27;, error);
      }
    };

    // Ejecutamos la función
    fetchUsers();
  }, []);

  return (
    &lt;div&gt;
      &lt;h1&gt;Usuarios&lt;/h1&gt;
      &lt;ul&gt;
        {users.map(user =&gt; (
          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};</code></pre>

      <h3 id="cleanup-abort-controller">Cleanup con AbortController</h3>
      <p>
        Cuando un componente se desmonta mientras una petición está en curso,
        puede causar memory leaks o errores al intentar actualizar el estado.
        AbortController nos permite cancelar peticiones pendientes:
      </p>
      <pre><code>import { useState, useEffect } from &#x27;react&#x27;;

const UserList = () =&gt; {
  const [users, setUsers] = useState([]);

  useEffect(() =&gt; {
    // Creamos un controlador para abortar la petición
    const controller = new AbortController();

    const fetchUsers = async () =&gt; {
      try {
        const response = await fetch(&#x27;https://jsonplaceholder.typicode.com/users&#x27;, {
          signal: controller.signal // Conectamos el signal
        });
        const data = await response.json();
        setUsers(data);
      } catch (error) {
        // Ignoramos errores de abort
        if (error.name !== &#x27;AbortError&#x27;) {
          console.error(&#x27;Error fetching data:&#x27;, error);
        }
      }
    };

    fetchUsers();

    // Cleanup: cancelamos la petición si el componente se desmonta
    return () =&gt; controller.abort();
  }, []);

  return (
    &lt;div&gt;
      &lt;h1&gt;Usuarios&lt;/h1&gt;
      &lt;ul&gt;
        {users.map(user =&gt; (
          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};</code></pre>

      <p>
        <strong>Nota:</strong> Estos ejemplos básicos no incluyen estados de
        carga ni manejo de errores para el usuario. En la siguiente sección
        veremos cómo implementar una solución más completa y profesional.
      </p>

      <h3 id="manejo-de-errores-y-carga">Manejo de errores y carga</h3>
      <p>
        En aplicaciones reales, es crucial comunicar al usuario el estado de las
        peticiones HTTP. Para esto, utilizamos tres estados que trabajan en
        conjunto:
      </p>
      <ul>
        <li><strong>data</strong> (users): Los datos obtenidos de la API</li>
        <li>
          <strong>loading</strong> (isLoading): Indica si la petición está en
          curso
        </li>
        <li>
          <strong>error</strong>: Almacena cualquier error que ocurra durante la
          petición
        </li>
      </ul>
      <p>
        Estos tres estados forman el patrón estándar de manejo de peticiones
        asíncronas en React.
      </p>

      <h4>Implementación básica</h4>
      <pre><code>import { useState, useEffect } from &#x27;react&#x27;;

const UserList = () =&gt; {
  // Estado para los datos
  const [users, setUsers] = useState([]);
  // Estado para la carga
  const [isLoading, setIsLoading] = useState(true);
  // Estado para errores
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    const fetchUsers = async () =&gt; {
      try {
        const response = await fetch(&#x27;https://jsonplaceholder.typicode.com/users&#x27;);

        // Verificamos si la respuesta fue exitosa
        if (!response.ok) {
          throw new Error(`Error HTTP: ${response.status}`);
        }

        const data = await response.json();
        setUsers(data);
      } catch (error) {
        // Guardamos el mensaje de error
        setError(error.message);
      } finally {
        // Siempre desactivamos el loading
        setIsLoading(false);
      }
    };

    // IMPORTANTE: Ejecutamos la función
    fetchUsers();
  }, []);

  // Renderizado condicional: mostramos loading
  if (isLoading) {
    return &lt;p&gt;Cargando usuarios...&lt;/p&gt;;
  }

  // Renderizado condicional: mostramos error
  if (error) {
    return &lt;p&gt;Error: {error}&lt;/p&gt;;
  }

  // Renderizado normal: mostramos los datos
  return (
    &lt;div&gt;
      &lt;h1&gt;Usuarios&lt;/h1&gt;
      &lt;ul&gt;
        {users.map(user =&gt; (
          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};

export default UserList;</code></pre>

      <h4>Implementación profesional con cleanup</h4>
      <p>
        Una implementación más robusta incluye AbortController para cancelar
        peticiones pendientes y evitar actualizaciones de estado en componentes
        desmontados:
      </p>
      <pre><code>import { useState, useEffect } from &#x27;react&#x27;;

const UserList = () =&gt; {
  const [users, setUsers] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    const controller = new AbortController();

    const fetchUsers = async () =&gt; {
      try {
        setIsLoading(true);
        setError(null);

        const response = await fetch(
          &#x27;https://jsonplaceholder.typicode.com/users&#x27;,
          { signal: controller.signal }
        );

        if (!response.ok) {
          throw new Error(`Error HTTP: ${response.status}`);
        }

        const data = await response.json();
        setUsers(data);
      } catch (error) {
        // Ignoramos errores de cancelación
        if (error.name !== &#x27;AbortError&#x27;) {
          setError(error.message);
        }
      } finally {
        setIsLoading(false);
      }
    };

    fetchUsers();

    // Cleanup: cancelamos la petición al desmontar
    return () =&gt; controller.abort();
  }, []);

  if (isLoading) {
    return (
      &lt;div&gt;
        &lt;h1&gt;Usuarios&lt;/h1&gt;
        &lt;p&gt;Cargando usuarios...&lt;/p&gt;
      &lt;/div&gt;
    );
  }

  if (error) {
    return (
      &lt;div&gt;
        &lt;h1&gt;Usuarios&lt;/h1&gt;
        &lt;p style={{ color: &#x27;red&#x27; }}&gt;Error: {error}&lt;/p&gt;
        &lt;button onClick={() =&gt; window.location.reload()}&gt;
          Reintentar
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div&gt;
      &lt;h1&gt;Usuarios ({users.length})&lt;/h1&gt;
      {users.length === 0 ? (
        &lt;p&gt;No hay usuarios disponibles&lt;/p&gt;
      ) : (
        &lt;ul&gt;
          {users.map(user =&gt; (
            &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )}
    &lt;/div&gt;
  );
};

export default UserList;</code></pre>

      <h4>Patrón de estados y flujo</h4>
      <p>El flujo de estados sigue este patrón:</p>
      <ol>
        <li>
          <strong>Estado inicial:</strong> isLoading = true, error = null, data
          = []
        </li>
        <li>
          <strong>Durante la petición:</strong> isLoading permanece en true
        </li>
        <li>
          <strong>Si tiene éxito:</strong> isLoading = false, data se actualiza
        </li>
        <li>
          <strong>Si falla:</strong> isLoading = false, error contiene el
          mensaje
        </li>
      </ol>
      <p>
        <strong>Importante:</strong> El bloque <code>finally</code> garantiza
        que isLoading siempre se desactive, independientemente de si la petición
        fue exitosa o falló.
      </p>

      <h2 id="react-router">React Router</h2>
      <hr />
      <pre><code >El desarrollo de aplicaciones web con React a menudo comienza de manera simple, pero a medida que el proyecto crece, se vuelve esencial implementar una estructura organizada que permita la navegación entre diferentes vistas. Aquí es donde React Router se convierte en una herramienta vital. Cuando nuestra aplicación es demasiado complicada tanto funcional como estructuralmente, la organización en rutas no solo mejora la navegabilidad, sino que también hace que el código sea más estructurado y fácil de mantener.</code></pre>
      <h3 id="estructura-de-un-react-router">Estructura de un react router</h3>
      <pre><code >La estructura básica de un React Router implica varios componentes y conceptos que se repiten en sus versiones, lo cual es fundamental para comprender cómo funciona.</code></pre>
      <p>
        Provider: Funciona muy parecido a React Context. Permite comunicar
        propiedades, estados y actualizadores de estado entre componentes sin
        Prop Drilling.
      </p>
      <pre><code >Link: En lugar de etiquetas &lt;a&gt;, se utiliza un componente Link que proviene de la dependencia React Router.
Route: Define las rutas de la aplicación. Utilizando las propiedades path y render (o similar), se determina qué componentes deben renderizarse en cada ruta.
Además, los Routers suelen permitir la inclusión de un Menú o Footer que se renderice en todas las vistas, asegurando una composición constante en la estructura de la aplicación.</code></pre>
      <h3 id="tipos-de-routers">Tipos de routers</h3>
      <pre><code >En el fascinante mundo del desarrollo web, React Router DOM nos ofrece tres tipos de routers: browser router, hash router y memory router. Cada uno de ellos tiene un propósito específico y una manera particular de gestionar la navegación, lo que influye en cómo se estructuran y gestionan las rutas en diferentes escenarios.</code></pre>
      <p>
        El browser router sigue la forma normal de navegación que encontramos en
        la mayoría de las páginas web. Si alguna vez has navegado por sitios
        como Platzi o Netflix, habrás notado que las URLs están estructuradas
        con barras inclinadas (slashes) para separar rutas como /home, /blog o
        /contact. Este tipo de router muestra la ruta completa en la barra de
        direcciones y es ideal para aplicaciones web que requieren rutas
        visibles y manejables directamente por el navegador.
      </p>
      <p>
        El hash router utiliza el símbolo de hash (&#x27;#&#x27;) después del
        dominio en la URL para gestionar las rutas. Así, una URL podría verse
        como example.com/#/ruta/blog. Este método es particularmente útil cuando
        se desea implementar rutas en una sola página (Single Page Application)
        sin intervención del servidor para cada cambio de ruta.
      </p>
      <p>
        El memory router es ideal para aplicaciones que no dependen de URLs
        navegables, como las aplicaciones móviles. Su funcionamiento se basa en
        mantener un array en memoria que rastrea las rutas, sin mostrar ninguna
        URL específica al usuario.
      </p>
      <h3 id="instalacion">Instalacion</h3>
      <p>
        Para instalar react router corremos el comando npm install
        react-router-dom@latest. Podemos asegurarnos que este todo bien
        corriendo la aplicación con npm run dev.
      </p>
      <h3 id="rutas-estaticas-hashrouter">Rutas estaticas (HashRouter)</h3>
      <pre><code >Podemos colocar rutas estaticas con hash dentro de nuestro documento vamos a usar el componente HashRouter react router. Para esto dentro de nuestro archivo app.jsx colocamos
function App() {
  return (
    &lt;&gt;
      &lt;HashRouter&gt;
        &lt;Menu /&gt;</code></pre>
      <pre><code >        &lt;Routes&gt;
          &lt;Route path=&quot;/&quot; element={&lt;HomePage /&gt;} /&gt;
          &lt;Route path=&quot;/profile&quot; element={&lt;ProfilePage /&gt;} /&gt;
          &lt;Route path=&quot;/blog&quot; element={&lt;BlogPage /&gt;} /&gt;
          &lt;Route</code></pre>
      <p>path=&quot;*&quot;</p>
      <pre><code >            element={&lt;h1 className=&quot;text-3xl font-bold&quot;&gt;Not Found&lt;/h1&gt;}
          /&gt;
        &lt;/Routes&gt;
      &lt;/HashRouter&gt;
    &lt;/&gt;
  );
}
Y dentro de este componente tendremos las paginas/rutas que vamos a renderizar dentro del componente Routes, y cada ruta por separado va a usar el componente Route. Dicho componente va a tener un atributo path que es el hash que va a leer, como tambien va a tener el atributo element que hara referencia a lo que se va a renderizar.</code></pre>
      <h3 id="navegacion-navlink">Navegacion (NavLink)</h3>
      <pre><code >Podemos usar la etiqueta NavLink en vez de la eliqueta a para crear links. Esta etiqueta nos permite cambiar la url de la app sin necesidad de recargar la pagina. Asi tendremos algo como
const routes = [
  { to: &#x27;/&#x27;, text: &#x27;Home&#x27; },
  { to: &#x27;/blog&#x27;, text: &#x27;Blog&#x27; },
  { to: &#x27;/profile&#x27;, text: &#x27;Profile&#x27; }</code></pre>
      <p>];</p>
      <pre><code >&lt;ul&gt;
  {routes.map(route =&gt; (
    &lt;li key={route.to}&gt;
      &lt;NavLink to={route.to} style={({ isActive }) =&gt; ({ color: isActive ? &#x27;red&#x27; : &#x27;blue&#x27; })}&gt;
        {route.text}
      &lt;/NavLink&gt;
    &lt;/li&gt;
  ))}
&lt;/ul&gt;
Que nos dara como resultado una lista ul con etiquetas NavLink relacionadas a las rutas definidas en la constante routes. Ademas, si estamos ubicados sobre esa opción se va a colocar en rojo.</code></pre>
      <h3 id="rutas-dinamicas-useparams">Rutas dinamicas (UseParams)</h3>
      <p>
        El slug es una parte de la URL que actúa como un identificador único
        para las páginas o elementos de contenido en una aplicación,
        generalmente al final de la URL como
        platzi.com/clases/como-aprender-react.
      </p>
      <p>
        Gracias al slug podemos cambiar el contenido interno de un componente
        manteniendo la misma estructura. El slug permite al componente entender
        qué datos cargar y cómo consultar el backend para obtener información
        diferente para cada vista.
      </p>
      <pre><code >Empezamos creando una lista de publicaciones para un blog. El componente base será similar para cada entrada de blog, cambiando solo su contenido dependiendo del slug. Este componente se llamará BlogPost y hará uso del React hook useParams para este objetivo. Veamos cómo se hace, comencemos definifiendo los datos de cada blog.
const blogData = [
  {</code></pre>
      <ul>
        <li>title: &quot;¿Qué es React?&quot;,</li>
        <li>slug: &quot;que-es-react&quot;,</li>
        <li>
          content: &quot;React es el mejor framework de JavaScript.&quot;,
        </li>
        <li>author: &quot;Juan de Sen&quot;</li>
      </ul>
      <pre><code >  },
  {</code></pre>
      <ul>
        <li>title: &quot;¿Qué es Vue?&quot;,</li>
        <li>slug: &quot;que-es-vue&quot;,</li>
        <li>content: &quot;Vue es un framework progresivo.&quot;,</li>
        <li>author: &quot;Otro autor&quot;</li>
      </ul>
      <pre><code >  }</code></pre>
      <p>];</p>
      <pre><code >Después diremos que la parte de pagina de blogs va a mostrar una lista con los distintos post para leer, y en la parte de to en el Link es donde vamos a colocar la parte dinamica
const BlogPage = () =&gt; {
  return (
    &lt;ul&gt;
      {blogData.map(post =&gt; (
        &lt;li key={post.slug}&gt;
          &lt;Link to={`/blog/${post.slug}`}&gt;{post.title}&lt;/Link&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};</code></pre>
      <p>
        Después en nuestro archivo app.jsx definimos que se va a renderizar
        cuando entremos a esa ruta dinamica, en este caso vamos a renderizar un
        componente llamado BlogPost.
      </p>
      <pre><code >function App() {
  return (
    &lt;Router&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/blog&quot; element={&lt;BlogPage /&gt;} /&gt;
        &lt;Route path=&quot;/blog/:slug&quot; element={&lt;BlogPost /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/Router&gt;
  );
}</code></pre>
      <p>
        Por ultimo, creamos el componente BlogPost que va a tener la estructura
        del los blogs pero cuya información va a variar dependiendo del post.
      </p>
      <pre><code >const BlogPost = () =&gt; {
  const { slug } = useParams();  // Obtiene el slug desde la URL</code></pre>
      <p>// Lógica para obtener el post correcto basado en el slug</p>
      <pre><code >  const post = blogData.find(post =&gt; post.slug === slug);</code></pre>
      <pre><code >  return (
    &lt;div&gt;
      &lt;h2&gt;{post.title}&lt;/h2&gt;
      &lt;p&gt;{post.content}&lt;/p&gt;
      &lt;p&gt;{post.author}&lt;/p&gt;
    &lt;/div&gt;
  );
};</code></pre>
      <h3 id="rutas-anidadas-outlet">Rutas anidadas (Outlet)</h3>
      <pre><code >Las Nested Routes, como su nombre lo indica, son rutas anidadas dentro de otras. Imagina tener una aplicación web donde una ruta principal tiene subrutas que se exploran sin perder el contenido original de la ruta principal.</code></pre>
      <p>
        Dentro del archivo app.jsx vamos a encapsular las rutas dinamicas de los
        post dentro de la ruta de BlogPage
      </p>
      <pre><code >&lt;Route path=&quot;/blog&quot; element={&lt;BlogPage /&gt;}&gt;
  &lt;Route path=&quot;post/:postId&quot; element={&lt;BlogPost /&gt;} /&gt;
&lt;/Route&gt;
Después dentro del componente BlogPage.jsx agregamos la etiqueta Outlet
function BlogPage() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Blog&lt;/h1&gt;
      &lt;Outlet /&gt;
    &lt;/div&gt;
  );
}
Al hacer esto, cuando navegas a una ruta secundaria, como un post de blog específico, el contenido de esa ruta se renderiza en el lugar donde está ubicado el Outlet.</code></pre>
      <h2 id="autenticacion">Autenticacion</h2>
      <p>
        Vamos a crear un sistema de autenticación ficticio para ilustrar cómo se
        podría implementar un flujo de autenticación.
      </p>
      <p>
        Primero creamos las paginas de login y logout que queremos crear, para
        la pagina del Login tendremos
      </p>
      <pre><code >import { useState } from &quot;react&quot;;
import { useAuth } from &quot;../auth/auth.jsx&quot;;</code></pre>
      <pre><code >export default function LoginPage() {
  const auth = useAuth();</code></pre>
      <pre><code >  const [username, setUsername] = useState(&quot;&quot;);</code></pre>
      <pre><code >  function login(event) {</code></pre>
      <p>event.preventDefault();</p>
      <pre><code >    auth.login({ username });
  }</code></pre>
      <pre><code >  return (
    &lt;&gt;
      &lt;h1 className=&quot;text-3xl font-bold&quot;&gt;Login&lt;/h1&gt;</code></pre>
      <pre><code >      &lt;form onSubmit={login} className=&quot;flex flex-col gap-1.5&quot;&gt;
        &lt;label htmlFor=&quot;username&quot;&gt;Escribe tu nombre de usuario&lt;/label&gt;
        &lt;input</code></pre>
      <ul>
        <li>type=&quot;text&quot;</li>
        <li>id=&quot;username&quot;</li>
      </ul>
      <pre><code >          value={username}
          onChange={(e) =&gt; setUsername(e.target.value)}
          className=&quot;bg-gray-200 rounded-md&quot;
        /&gt;
        &lt;button type=&quot;submit&quot;&gt;Enviar&lt;/button&gt;
      &lt;/form&gt;
    &lt;/&gt;
  );
}</code></pre>
      <p>Para la pagina del logout tendremos</p>
      <pre><code >import { useState } from &quot;react&quot;;
import { useAuth } from &quot;../auth/auth.jsx&quot;;</code></pre>
      <pre><code >export default function LoginPage() {
  const auth = useAuth();</code></pre>
      <pre><code >  const [username, setUsername] = useState(&quot;&quot;);</code></pre>
      <pre><code >  function login(event) {</code></pre>
      <p>event.preventDefault();</p>
      <pre><code >    auth.login({ username });
  }</code></pre>
      <pre><code >  return (
    &lt;&gt;
      &lt;h1 className=&quot;text-3xl font-bold&quot;&gt;Login&lt;/h1&gt;</code></pre>
      <pre><code >      &lt;form onSubmit={login} className=&quot;flex flex-col gap-1.5&quot;&gt;
        &lt;label htmlFor=&quot;username&quot;&gt;Escribe tu nombre de usuario&lt;/label&gt;
        &lt;input</code></pre>
      <ul>
        <li>type=&quot;text&quot;</li>
        <li>id=&quot;username&quot;</li>
      </ul>
      <pre><code >          value={username}
          onChange={(e) =&gt; setUsername(e.target.value)}
          className=&quot;bg-gray-200 rounded-md&quot;
        /&gt;
        &lt;button type=&quot;submit&quot;&gt;Enviar&lt;/button&gt;
      &lt;/form&gt;
    &lt;/&gt;
  );
}
Tenemos que añadir estas paginas en el HashRouter
&lt;Route path=&quot;/login&quot; element={&lt;LoginPage /&gt;} /&gt;
&lt;Route path=&quot;/logout&quot; element={&lt;LogoutPage /&gt;} /&gt;
&lt;Route path=&quot;/profile&quot; element={&lt;ProfilePage /&gt;} /&gt;</code></pre>
      <p>Como tambien agregarlas al menu</p>
      <pre><code >const routes = [
  { to: &quot;/&quot;, text: &quot;Home&quot; },
  { to: &quot;/profile&quot;, text: &quot;Profile&quot; },
  { to: &quot;/blog&quot;, text: &quot;Blog&quot; },
  { to: &quot;/login&quot;, text: &quot;Login&quot; },
  { to: &quot;/logout&quot;, text: &quot;Logout&quot; },</code></pre>
      <p>];</p>
      <p>
        Después, vamos a querer usar metodos y estados en toda la aplicación,
        por lo que vamos a necesitar un archivo de autenticacion que use un
        reactContext y envie estos valores a traves de un provider. Empezemos
        diciendole a la aplicación que va a usar valores del provider,
        modificamos nuestro archivo app.jsx
      </p>
      <pre><code >&lt;HashRouter&gt;
   &lt;AuthProvider&gt;
      &lt;Menu /&gt;</code></pre>
      <pre><code >      &lt;Routes&gt;
        &lt;Route path=&quot;/&quot; element={&lt;HomePage /&gt;} /&gt;</code></pre>
      <ul>
        <li>…</li>
        <li>…</li>
      </ul>
      <pre><code >      &lt;/Routes&gt;
   &lt;/AuthProvider&gt;
&lt;/HashRouter&gt;</code></pre>
      <p>
        Ahora tenemos que crear nuestro archivo auth.jsx que es donde vamos a
        crear el contexto y los valores que va a enviar el provider
      </p>
      <pre><code >import React from &quot;react&quot;;
import { useNavigate } from &quot;react-router-dom&quot;;</code></pre>
      <p>// context</p>
      <pre><code >const AuthContext = React.createContext();</code></pre>
      <p>// provider</p>
      <pre><code >function AuthProvider({ children }) {</code></pre>
      <p>// navigation</p>
      <pre><code >  const navigate = useNavigate();</code></pre>
      <p>// state</p>
      <pre><code >  const [user, setUser] = React.useState(null);</code></pre>
      <p>// methods</p>
      <pre><code >  const login = ({ username }) =&gt; {
    setUser({ username });</code></pre>
      <p>navigate(&quot;/profile&quot;);</p>
      <pre><code >  };
  const logout = () =&gt; {</code></pre>
      <p>setUser(null);</p>
      <p>navigate(&quot;/&quot;);</p>
      <pre><code >  };</code></pre>
      <p>// values</p>
      <pre><code >  const auth = { user, login, logout };</code></pre>
      <p>// send values to provider</p>
      <pre><code >  return &lt;AuthContext.Provider value={auth}&gt;{children}&lt;/AuthContext.Provider&gt;;
}</code></pre>
      <p>// hook</p>
      <pre><code >function useAuth() {
  const auth = React.useContext(AuthContext);
  return auth;
}</code></pre>
      <pre><code >export { useAuth, AuthProvider };</code></pre>
      <h3 id="proteger-rutas-con-autenticacion">
        proteger rutas con autenticacion
      </h3>
      <p>
        primero tenemos que definir que rutas seran publicas y cuales seran
        privadas, para esto vamos a crear una tercera propiedad de las rutas
      </p>
      <pre><code >const routes = [
  { to: &quot;/&quot;, text: &quot;Home&quot;, private: false },
  { to: &quot;/profile&quot;, text: &quot;Profile&quot;, private: true },
  { to: &quot;/blog&quot;, text: &quot;Blog&quot;, private: false },
  { to: &quot;/login&quot;, text: &quot;Login&quot;, private: false },
  { to: &quot;/logout&quot;, text: &quot;Logout&quot;, private: true },</code></pre>
      <p>];</p>
      <p>
        Después en nuestro menus donde renderizamos las rutas vamos a usar un
        condicional, tal que si existe un usuario vamos a mostrar la ruta
      </p>
      <pre><code >export default function Menu() {
  const auth = useAuth();</code></pre>
      <pre><code >  return (
    &lt;nav&gt;
      &lt;ul className=&quot;flex flex-row gap-4&quot;&gt;
        {routes.map((route) =&gt; {
          if (route.private &amp;&amp; !auth.user) return null;
          if(route.to == &#x27;/login&#x27; &amp;&amp; auth.user){
            return null
          }</code></pre>
      <pre><code >          return (
            &lt;li key={route.text}&gt;
              &lt;NavLink
                style={({ isActive }) =&gt; ({</code></pre>
      <p>color: isActive ? &quot;red&quot; : &quot;blue&quot;,</p>
      <pre><code >                })}
                to={route.to}</code></pre>
      <p>&gt;</p>
      <pre><code >                {route.text}
              &lt;/NavLink&gt;
            &lt;/li&gt;
          );
        })}
      &lt;/ul&gt;
    &lt;/nav&gt;
  );
}</code></pre>
      <h3 id="proteccion-de-rutas-con-redireccionamiento">
        Proteccion de rutas con redireccionamiento
      </h3>
      <p>
        Cuando desarrollamos aplicaciones web, uno de los aspectos más cruciales
        es proteger adecuadamente las rutas. Podemos ocultar rutas del menú,
        pero todavía pueden ser accesibles a través de la URL directa. Siguiendo
        las mejores prácticas de React, es vital garantizar que los usuarios no
        autenticados no puedan acceder a ciertas páginas y que los usuarios
        autenticados no sean redirigidos a páginas de acceso.
      </p>
      <p>
        Implementar rutas protegidas implica involucrar un componente que
        gestione las redirecciones según el estado de autenticación del usuario.
        Crear un componente reutilizable es la mejor estrategia para evitar la
        repetición de código.
      </p>
      <p>Dentro de nuestro archivo auth.jsx vamos a crear el componente</p>
      <pre><code >const AuthRoute = ({ children }) =&gt; {
  const auth = useAuth();</code></pre>
      <pre><code >  if (!auth.user) {
    return &lt;Navigate to=&quot;/login&quot; /&gt;;
  }</code></pre>
      <pre><code >  return children;
};</code></pre>
      <p>
        Después, en nuestro archivo app.jsx protegemos las rutas privadas dentro
        usando el componente
      </p>
      <pre><code >&lt;Route</code></pre>
      <p>path=&quot;/logout&quot;</p>
      <pre><code >        element={
        &lt;AuthRoute&gt;
          &lt;LogoutPage /&gt;
        &lt;/AuthRoute&gt;
        }
/&gt;
&lt;Route</code></pre>
      <p>path=&quot;/profile&quot;</p>
      <pre><code >        element={
        &lt;AuthRoute&gt;
         &lt;ProfilePage /&gt;
        &lt;/AuthRoute&gt;
         }
 /&gt;</code></pre>
      <p>
        Por ultimo, si ya iniciamos sesion no deberiamos poder ir denuevo a la
        pagina de login, por lo que en el archivo LoginPage agregamos
      </p>
      <pre><code >if (auth.user) {
    return &lt;p&gt;Ya has iniciado sesion como {auth.user.username}&lt;/p&gt;;
  }</code></pre>
      <p>
        Para que nos regrese ese mensaje y no el formulario para hacer login.
      </p>
      <h3 id="roles-y-autorizacion">Roles y autorizacion</h3>
      <p>Empezamos creando una lista de administradores</p>
      <pre><code >export const adminList = [&quot;admin1&quot;, &quot;admin2&quot;, &quot;admin3&quot;];</code></pre>
      <p>
        y cuando hacemos login, ya no solo mandamos el username, sino que
        tambien verificamos si es admin o no
      </p>
      <pre><code >const login = ({ username }) =&gt; {
    const isAdmin = adminList.includes(username);
    setUser({ username, isAdmin });</code></pre>
      <p>navigate(&quot;/profile&quot;);</p>
      <pre><code >  };</code></pre>
      <p>
        Ahora podemos agregar una funcionalidad para los admins, como eliminar
        un blog, para esto en nuestro archivo BlogPost.jsx agregamos
      </p>
      <pre><code >export default function BlogPost() {
  const auth = useAuth();
  const { slug } = useParams();
  const post = blogData.find((post) =&gt; post.slug === slug);</code></pre>
      <pre><code >  return (
    &lt;div&gt;
      &lt;h2&gt;{post.title}&lt;/h2&gt;
      &lt;p&gt;{post.content}&lt;/p&gt;
      &lt;p&gt;{post.author}&lt;/p&gt;
      {auth.user?.isAdmin &amp;&amp; &lt;button&gt;Eliminar Post&lt;/button&gt;}
    &lt;/div&gt;
  );
}</code></pre>
    </main>
  </body>
</html>
