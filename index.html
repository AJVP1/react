<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="styles.css" />
    <title>React</title>
  </head>
  <body>
    <!-- navegacion -->
    <nav>
      <h2>Indice</h2>
    </nav>

    <!-- contenido principal -->
    <main>
      <h1>React</h1>
      <h2 id="introduccion">Introduccion</h2>
      <hr />

      <p>
        React es una librería de JavaScript orientada a la construcción de
        interfaces de usuario mediante un modelo declarativo basado en
        componentes. En React, la interfaz se define como una función del estado
        de la aplicación: cada vez que el estado cambia, React recalcula la
        representación de la UI y aplica al DOM real únicamente las diferencias
        necesarias.
      </p>

      <p>
        Para lograr esto, React utiliza una estructura interna conocida como
        Virtual DOM, que mantiene una representación en memoria del árbol de
        componentes. Mediante un proceso de reconciliation, React compara el
        árbol anterior con el nuevo y ejecuta actualizaciones mínimas sobre el
        DOM del navegador, optimizando el rendimiento.
      </p>

      <p>
        React implementa un flujo de datos unidireccional (one-way data
        binding), donde los cambios de estado se propagan desde componentes
        padres hacia hijos a través de props. Esta arquitectura favorece la
        previsibilidad del comportamiento de la aplicación y simplifica el
        razonamiento sobre el estado.
      </p>

      <p>
        Aunque React puede utilizarse para desarrollar Single Page Applications
        (SPA), no impone una arquitectura completa de aplicación.
        Funcionalidades como ruteo, gestión global del estado, manejo de efectos
        laterales y persistencia se integran mediante herramientas del
        ecosistema (por ejemplo, React Router, Context, Redux, entre otras).
      </p>

      <h2 id="empezar-un-proyecto">Empezar un proyecto</h2>
      <hr />
      <p>
        Para empezar a desarrollar nuestro frontend con react tenemos que estar
        parados en el root de nuestro proyecto y corremos el comando
        <code>pnpm create vite@latest</code> aquí seleccionamos las
        configuraciones para trabajar con react y esto nos creara la carpeta
        para el frontend.
      </p>

      <p>
        Esta carpeta viene con las configuraciones para usar react como
        node_modules, public, src, … etc. Y donde una vez tengamos listo el
        frontend para produccion corremos el comando npm run build.
      </p>
      <p>
        Dentro de src nos crea la carpeta de assets para las imágenes y 4
        archivos más, dos de estos archivo (main.jsx y index.css) son los
        principales, el archivo jsx es el que va a manejar toda la parte de
        renderizado en el DOM y el css es el que va a tener los estilos
        principales. Por otro lado, los archivos (app.css y app.jsx) son los
        archivos secundarios con una muestra de un componente de react en el
        archivo jsx, y los estilos del mismo en el archivo css.
      </p>
      <pre><code>function App() {
  const items = [&quot;react&quot;, &quot;javascript&quot;, &quot;git&quot;];
  return (
    &lt;section&gt;
      &lt;h1&gt;Hola mundo&lt;/h1&gt;
      &lt;ul&gt;
        {items.map((item, index) =&gt; (
          &lt;li key={index}&gt;{item}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/section&gt;
  );
}</code></pre>
      <p>
        En este ejemplo, usamos map() para renderizar una lista de elementos de
        forma declarativa, sin manipular el DOM manualmente.
      </p>
      <p>Las ventajas de este enfoque son evidentes:</p>
      <ul>
        <li>Código más declarativo y legible</li>
        <li>No es necesario manipular el DOM directamente</li>
        <li>Menos líneas de código para lograr el mismo resultado</li>
        <li>Mayor facilidad para mantener y actualizar</li>
      </ul>

      <h3 id="tailwind-en-react-con-vite">
        <em>Tailwind en react con vite</em>
      </h3>
      <p>
        Existen dos formas de instalar Tailwind CSS en un proyecto de React con
        Vite: la versión 3 (estándar y más utilizada) y la versión 4 (más nueva
        y simplificada).
      </p>

      <h4>Tailwind CSS v3 (Instalación estándar)</h4>
      <p>
        Esta es la forma más común y estable. Primero instalamos las
        dependencias necesarias:
      </p>
      <pre><code>pnpm install -D tailwindcss postcss autoprefixer
pnpm dlx tailwindcss init -p</code></pre>
      <p>
        Esto creará dos archivos: <code>tailwind.config.js</code> y
        <code>postcss.config.js</code>. Configuramos el
        <code>tailwind.config.js</code> para indicar dónde están nuestros
        archivos:
      </p>
      <pre><code>export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}</code></pre>
      <p>
        Luego, en el archivo <code>src/index.css</code> agregamos las directivas
        de Tailwind:
      </p>
      <pre><code>@tailwind base;
@tailwind components;
@tailwind utilities;</code></pre>
      <p>
        Y listo, ya podemos empezar a usar tailwind dentro de nuestros
        componentes en react.
      </p>

      <h4>Tailwind CSS v4 (Nueva versión simplificada)</h4>
      <p>
        La versión 4 simplifica el proceso de instalación. Instalamos tailwind
        con:
      </p>
      <pre><code>pnpm install -D tailwindcss @tailwindcss/vite</code></pre>
      <p>
        Después lo agregamos a la configuración en
        <code>vite.config.js</code>:
      </p>
      <pre><code>import { defineConfig } from 'vite';
import tailwindcss from '@tailwindcss/vite';

export default defineConfig({
  plugins: [
    tailwindcss(),
  ],
});</code></pre>
      <p>
        Y en el archivo <code>src/index.css</code> simplemente importamos
        tailwind:
      </p>
      <pre><code>@import "tailwindcss";</code></pre>
      <p>
        Con cualquiera de las dos versiones ya podemos usar las clases de
        Tailwind en nuestros componentes como si fuera HTML común.
      </p>

      <h2 id="componentes">Componentes</h2>
      <hr />
      <p>
        React simplifica el desarrollo de aplicaciones web al dejarnos hacer
        código en componentes reusables. Un componente en React es una función
        que devuelve algo que queremos que se muestre en la pantalla. Usualmente
        dichas funciones se crean como arrow functions para hacerlas más
        sencillas, aunque de igual manera está bien. Típicamente los componentes
        comienzan con una letra mayuscula para distinguirlos de las etiquetas de
        HTML, veamos un ejemplo
      </p>
      <pre><code>const MyComponent = () =&gt; { return "I'm a component"};</code></pre>
      <p>
        En React, los componentes no solo pueden devolver texto plano, también
        pueden devolver HTML. Por ejemplo
      </p>
      <pre><code>const Bienvenida = () =&gt; {
  return &lt;h1&gt;Hola, mundo&lt;/h1&gt;
};</code></pre>
      <p>
        A esto se le conoce como JSX, que parece HTML pero no lo es. Es una
        sintaxis especial que React usa para escribir código como HTML dentro de
        JavaScript.
      </p>
      <p>
        Para usar un componente dentro de otro, simplemente lo llamamos como si
        fuera una etiqueta HTML. Por ejemplo
      </p>
      <pre><code>const App = () =&gt; {
  return (
    &lt;section&gt;
      &lt;Bienvenida /&gt;
    &lt;/section&gt;
  );
};</code></pre>
      <p>
        Esto hace que el componente Bienvenida se renderice dentro del
        componente App.
      </p>

      <h3 id="props"><em>Props</em></h3>
      <p>
        Las props (abreviatura de &quot;properties&quot; o propiedades) son el
        mecanismo que React utiliza para pasar datos de un componente padre a un
        componente hijo. Funcionan como parámetros que permiten personalizar los
        componentes y hacerlos verdaderamente reutilizables. Por ejemplo
      </p>
      <pre><code>const Card = ({ title, content }) =&gt; {
  return (
    &lt;div&gt;
      &lt;h2&gt;{title}&lt;/h2&gt;
      &lt;p&gt;{content}&lt;/p&gt;
    &lt;/div&gt;
  );
};

export default Card;</code></pre>

      <p>
        En este ejemplo creamos un componente, usamos las propiedades title y
        content, y exportamos el componente.
      </p>
      <p>
        Para usar el componente lo usamos como si fuera una etiqueta html y
        definiendo en los atributos el contenido de las propiedades.
      </p>
      <pre><code >import Card from &quot;./components/Card&quot;;

function App() {
  return (
    &lt;section&gt;
      &lt;Card title=&quot;Cart uno&quot; content=&quot;Esta es una descripción&quot; /&gt;
    &lt;/section&gt;
  );
}

export default App;</code></pre>
      <p>
        Aquí importamos el componente Card y lo usamos dentro del componente
        App, pasando valores específicos para las props title y content.
      </p>

      <h3 id="estados-usestate"><em>Estados (useState) </em></h3>
      <p>
        El estado en React es un mecanismo para almacenar información que puede
        cambiar durante el ciclo de vida de un componente. Podemos visualizarlo
        como cajas de almacenamiento donde guardamos datos específicos que
        nuestros componentes necesitan para funcionar correctamente.
      </p>
      <p>Existen dos tipos principales de estados:</p>

      <ul>
        <li>
          Estado local: Información almacenada a nivel de componente, accesible
          solo dentro del componente donde se define.
        </li>
        <li>
          Estado global: Información compartida entre múltiples componentes de
          la aplicación.
        </li>
      </ul>

      <p>
        React proporciona una herramienta especial llamada useState, que es un
        hook que nos permite implementar estados locales en nuestros componentes
        funcionales. Este hook nos devuelve:
      </p>

      <ul>
        <li>Una variable para leer el valor actual del estado</li>
        <li>Una función para actualizar ese valor</li>
        <li>El valor inicial del estado</li>
      </ul>

      <p>La sintaxis básica es</p>
      <pre><code>const [valor, setValor] = useState(valorInicial);</code></pre>

      <p>
        donde <code>valor</code> es la variable que contiene el estado actual,
        <code>setValor</code> es la función que nos permite actualizar ese
        estado y <code>valorInicial</code> es el valor que con el que comienza
        el estado.
      </p>

      <p>Ejemplo</p>
      <pre><code>import { useState } from 'react';

const Counter = () =&gt; {
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;h2&gt;El contador está en: {count}&lt;/h2&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Incrementar&lt;/button&gt;
      &lt;button onClick={() =&gt; setCount(count - 1)}&gt;Decrementar&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
      <p>
        Los estados locales son extremadamente versátiles y pueden utilizarse en
        numerosos escenarios:
      </p>
      <ul>
        <li>
          Formularios: Para almacenar los valores de los campos mientras el
          usuario los completa
        </li>
        <li>
          Toggles: Para manejar estados de activado/desactivado (como menús
          desplegables)
        </li>
        <li>
          Filtros: Para almacenar criterios de filtrado en listas o colecciones
        </li>
        <li>Paginación: Para mantener el número de página actual</li>
        <li>
          Cargas de datos: Para indicar si los datos están cargando, se han
          cargado correctamente o ha ocurrido un error
        </li>
      </ul>

      <h4>Ejemplo de toggle button</h4>
      <pre><code>import { useState } from 'react';

const ToggleButton = () =&gt; {
  const [isActive, setIsActive] = useState(false);

  return (
    &lt;button onClick={() =&gt; setIsActive(!isActive)}&gt;
      {isActive ? &#x27;Activo&#x27; : &#x27;Inactivo&#x27;}
    &lt;/button&gt;
  );
};</code></pre>

      <h4>Ejemplo de variable en formulario</h4>
      <pre><code>import { useState } from 'react';

const NameForm = () =&gt; {
  const [name, setName] = useState(&#x27;&#x27;);

  return (
    &lt;div&gt;
      &lt;input
        type=&quot;text&quot;
        value={name}
        placeholder=&quot;Ingresa tu nombre&quot;
        onChange={(event) =&gt; setName(event.target.value)}
      /&gt;
      &lt;p&gt;Hola, {name ? name : &#x27;visitante&#x27;}&lt;/p&gt;
    &lt;/div&gt;
  );
};</code></pre>

      <h4 id="multiples-estados-en-un-componente">
        Múltiples estados en un componente
      </h4>
      <p>
        En la mayoría de los casos, un componente necesita más de una variable
        de estado. Podemos utilizar múltiples llamadas a useState dentro del
        mismo componente:
      </p>
      <pre><code>import { useState } from 'react';

const UserProfile = () =&gt; {
  const [name, setName] = useState(&#x27;&#x27;);
  const [email, setEmail] = useState(&#x27;&#x27;);
  const [age, setAge] = useState(0);

  return (
    &lt;div&gt;
      &lt;input
        type=&quot;text&quot;
        placeholder=&quot;Nombre&quot;
        value={name}
        onChange={(e) =&gt; setName(e.target.value)}
      /&gt;
      &lt;input
        type=&quot;email&quot;
        placeholder=&quot;Email&quot;
        value={email}
        onChange={(e) =&gt; setEmail(e.target.value)}
      /&gt;
      &lt;input
        type=&quot;number&quot;
        placeholder=&quot;Edad&quot;
        value={age}
        onChange={(e) =&gt; setAge(Number(e.target.value))}
      /&gt;
      &lt;p&gt;Perfil: {name} ({age} años) - {email}&lt;/p&gt;
    &lt;/div&gt;
  );
};</code></pre>
      <h4 id="actualizacion-basada-en-el-estado-anterior">
        Actualización basada en el estado anterior
      </h4>
      <p>
        A veces necesitamos actualizar el estado basándonos en su valor
        anterior. En lugar de pasar un valor directamente, podemos pasar una
        función que recibe el estado anterior y retorna el nuevo estado:
      </p>
      <pre><code>import { useState } from 'react';

const CounterAdvanced = () =&gt; {
  const [count, setCount] = useState(0);

  // Forma correcta: pasar una función
  const increment = () =&gt; {
    setCount((prevCount) =&gt; prevCount + 1);
  };

  const decrement = () =&gt; {
    setCount((prevCount) =&gt; prevCount - 1);
  };

  const reset = () =&gt; {
    setCount(0);
  };

  return (
    &lt;div&gt;
      &lt;p&gt;Contador: {count}&lt;/p&gt;
      &lt;button onClick={increment}&gt;Incrementar&lt;/button&gt;
      &lt;button onClick={decrement}&gt;Decrementar&lt;/button&gt;
      &lt;button onClick={reset}&gt;Reiniciar&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
      <p>
        Esta forma de actualizar es especialmente importante cuando realizas
        múltiples actualizaciones del estado en rápida sucesión o cuando la
        actualización depende del estado anterior. React agrupa las
        actualizaciones (batching) para optimizar el rendimiento, por lo que
        siempre es recomendable usar la función callback cuando el nuevo estado
        depende del anterior.
      </p>

      <h3 id="efectos-secundarios-useeffect">
        <em>Efectos secundarios (useEffect)</em>
      </h3>
      <p>
        Los efectos secundarios son operaciones que ocurren fuera del flujo
        principal de renderizado de React. Estos incluyen:
      </p>
      <ul>
        <li>Llamadas a APIs externas</li>
        <li>Suscripciones a eventos</li>
        <li>Manipulación del DOM</li>
        <li>Temporizadores (setTimeout, setInterval)</li>
        <li>Almacenamiento en localStorage</li>
      </ul>
      <p>
        El hook useEffect fue diseñado específicamente para manejar estos
        efectos secundarios, permitiéndonos ejecutar código después de que el
        componente se haya renderizado en la pantalla.
      </p>
      <p>El hook useEffect recibe dos parámetros:</p>
      <ul>
        <li>Una función que contiene el código a ejecutar</li>
        <li>
          Un array de dependencias (opcional) que determina cuándo se ejecutará
          el efecto
        </li>
      </ul>
      <pre><code>useEffect(() =&gt; {}, [dependencias]);</code></pre>
      <p>
        Si el array de dependencias está vacío [], el efecto se ejecutará solo
        una vez después del primer renderizado. Si incluimos variables en el
        array, el efecto se ejecutará cada vez que alguna de esas variables
        cambie de valor.
      </p>
      <p>Ejemplo básico con dependencias:</p>
      <pre><code>import { useState, useEffect } from 'react';

const CounterWithEffect = () =&gt; {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    console.log(`El contador cambió a ${count}`);
  }, [count]);

  return (
    &lt;div&gt;
      &lt;p&gt;Count: {count}&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Incrementar&lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>
      <p>
        El hook useEffect es extremadamente versátil y puede utilizarse en
        numerosos escenarios:
      </p>
      <ul>
        <li>
          Obtención de datos: Realizar peticiones a APIs cuando un componente se
          monta o cuando cambian ciertos parámetros
        </li>
        <li>
          Suscripciones: Establecer listeners de eventos y limpiarlos cuando el
          componente se desmonta
        </li>
        <li>
          Manipulación del DOM: Actualizar el título de la página o interactuar
          con elementos del DOM
        </li>
        <li>
          Animaciones: Iniciar o detener animaciones basadas en cambios de
          estado
        </li>
        <li>
          Persistencia de datos: Guardar información en localStorage cuando
          cambian ciertos valores
        </li>
      </ul>

      <h4 id="funcion-cleanup-useeffect">Función cleanup en useEffect</h4>
      <p>
        Cuando necesitamos limpiar recursos (suscripciones, timers, listeners),
        podemos retornar una función desde useEffect que se ejecutará al
        desmontar el componente o antes de ejecutar el efecto nuevamente:
      </p>
      <pre><code>import { useState, useEffect } from 'react';

const SubscriptionExample = () =&gt; {
  const [isSubscribed, setIsSubscribed] = useState(false);

  useEffect(() =&gt; {
    // Setup: ejecuta cuando el componente monta
    if (isSubscribed) {
      console.log('Suscrito a eventos');
      const handleEvent = () =&gt; console.log('Evento disparado');
      window.addEventListener('scroll', handleEvent);

      // Cleanup: se ejecuta antes de desmontar o antes del siguiente efecto
      return () =&gt; {
        console.log('Desuscrito de eventos');
        window.removeEventListener('scroll', handleEvent);
      };
    }
  }, [isSubscribed]);

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setIsSubscribed(!isSubscribed)}&gt;
        {isSubscribed ? 'Desuscribirse' : 'Suscribirse'}
      &lt;/button&gt;
    &lt;/div&gt;
  );
};</code></pre>

      <h4 id="useeffect-sin-dependencias-monta-y-desmonta">
        useEffect sin dependencias (monta y desmonta)
      </h4>
      <pre><code>import { useState, useEffect } from 'react';

const TimerExample = () =&gt; {
  const [seconds, setSeconds] = useState(0);

  useEffect(() =&gt; {
    // Corre una sola vez cuando el componente monta
    const interval = setInterval(() =&gt; {
      setSeconds((prev) =&gt; prev + 1);
    }, 1000);

    // Cleanup: se ejecuta cuando el componente desmonta
    return () =&gt; clearInterval(interval);
  }, []); // Array vacío = solo al montar/desmontar

  return &lt;p&gt;Tiempo: {seconds} segundos&lt;/p&gt;;
};</code></pre>

      <h4 id="useeffect-para-obtener-datos">useEffect para obtener datos</h4>
      <pre><code>import { useState, useEffect } from 'react';

const DataFetcher = ({ userId }) =&gt; {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    // Reset states
    setLoading(true);
    setError(null);

    // Fetch de datos
    fetch(`https://api.example.com/users/${userId}`)
      .then((response) =&gt; {
        if (!response.ok) throw new Error('Error en la API');
        return response.json();
      })
      .then((data) =&gt; setUser(data))
      .catch((err) =&gt; setError(err.message))
      .finally(() =&gt; setLoading(false));
  }, [userId]); // Se ejecuta cada vez que userId cambia

  if (loading) return &lt;p&gt;Cargando...&lt;/p&gt;;
  if (error) return &lt;p&gt;Error: {error}&lt;/p&gt;;
  return &lt;div&gt;&lt;h2&gt;{user?.name}&lt;/h2&gt;&lt;/div&gt;;
};</code></pre>
      <p>
        <strong>Importante:</strong> La función cleanup retornada desde
        useEffect es esencial para evitar memory leaks. Siempre limpia
        listeners, timers, o suscripciones que hayas establecido en el efecto.
      </p>

      <h3 id="estados-complejos-usereducer">
        <em>Estados complejos (useReducer)</em>
      </h3>
      <p>
        A diferencia de useState, que simplemente reemplaza el estado anterior,
        useReducer permite definir una función reductora (reducer) que
        especifica cómo el estado debe cambiar en respuesta a diferentes
        acciones. Esta estructura se asemeja al patrón de diseño Redux, pero
        integrado directamente en React.
      </p>
      <p>La sintaxis básica de useReducer incluye:</p>
      <pre><code>const [state, dispatch] = useReducer(reducer, initialState);</code></pre>
      <p>
        Donde <code>state</code> es el estado actual, <code>dispatch</code> es
        una función para enviar acciones al reducer, <code>reducer</code> es una
        función que determina cómo actualizar el estado basado en la acción, e
        <code>initialState</code> es el valor inicial.
      </p>
      <h4 id="cuando-usar-usereducer">
        ¿Cuándo usar useReducer en lugar de useState?
      </h4>
      <p>Usa useReducer cuando:</p>
      <ul>
        <li>El estado tiene múltiples valores relacionados entre sí</li>
        <li>
          La lógica de actualización es compleja o tiene muchas condiciones
        </li>
        <li>
          El siguiente estado depende del estado anterior de forma compleja
        </li>
        <li>
          Quieres optimizar el rendimiento en componentes grandes (dispatch no
          cambia entre renders)
        </li>
        <li>Necesitas una lógica de estado más predecible y testeable</li>
      </ul>
      <p>Usa useState cuando:</p>
      <ul>
        <li>El estado es un valor simple (string, number, boolean)</li>
        <li>Las actualizaciones son directas y simples</li>
        <li>No hay mucha lógica condicional en las actualizaciones</li>
      </ul>

      <h4 id="ejemplo-basico-contador">Ejemplo básico: Contador</h4>
      <p>
        Empezamos definiendo la función reducer, esta recibirá dos argumentos,
        el primero es el estado y el segundo es la acción.
      </p>
      <pre><code>import { useReducer } from &#x27;react&#x27;;

// Función reducer
const reducer = (state, action) =&gt; {
  // definimos acciones según el tipo de acción
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    case "reset":
      return { count: 0 };
    default:
      return state;
  }
};

// Componente
const Counter = () =&gt; {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    &lt;div&gt;
      &lt;p&gt;Contador: {state.count}&lt;/p&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#x27;increment&#x27; })}&gt;
        Incrementar
      &lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#x27;decrement&#x27; })}&gt;
        Decrementar
      &lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#x27;reset&#x27; })}&gt;
        Reiniciar
      &lt;/button&gt;
    &lt;/div&gt;
  );
};

export default Counter;</code></pre>

      <h4 id="ejemplo-con-payload-carrito-de-compras">
        Ejemplo con payload: Carrito de compras
      </h4>
      <p>
        Las acciones pueden incluir datos adicionales (payload) para actualizar
        el estado. Veamos un ejemplo más complejo con un carrito de compras:
      </p>
      <pre><code>import { useReducer } from &#x27;react&#x27;;

// Mejores prácticas: usar constantes para los tipos de acción
const ACTIONS = {
  ADD_ITEM: &#x27;add_item&#x27;,
  REMOVE_ITEM: &#x27;remove_item&#x27;,
  UPDATE_QUANTITY: &#x27;update_quantity&#x27;,
  CLEAR_CART: &#x27;clear_cart&#x27;
};

// Reducer con lógica compleja
const cartReducer = (state, action) =&gt; {
  switch (action.type) {
    case ACTIONS.ADD_ITEM: {
      const existingItem = state.items.find(
        item =&gt; item.id === action.payload.id
      );

      if (existingItem) {
        return {
          ...state,
          items: state.items.map(item =&gt;
            item.id === action.payload.id
              ? { ...item, quantity: item.quantity + 1 }
              : item
          )
        };
      }

      return {
        ...state,
        items: [...state.items, { ...action.payload, quantity: 1 }]
      };
    }

    case ACTIONS.REMOVE_ITEM:
      return {
        ...state,
        items: state.items.filter(item =&gt; item.id !== action.payload.id)
      };

    case ACTIONS.UPDATE_QUANTITY:
      return {
        ...state,
        items: state.items.map(item =&gt;
          item.id === action.payload.id
            ? { ...item, quantity: action.payload.quantity }
            : item
        )
      };

    case ACTIONS.CLEAR_CART:
      return { items: [] };

    default:
      return state;
  }
};

// Componente del carrito
const ShoppingCart = () =&gt; {
  const [state, dispatch] = useReducer(cartReducer, { items: [] });

  const addItem = (item) =&gt; {
    dispatch({ type: ACTIONS.ADD_ITEM, payload: item });
  };

  const removeItem = (id) =&gt; {
    dispatch({ type: ACTIONS.REMOVE_ITEM, payload: { id } });
  };

  const updateQuantity = (id, quantity) =&gt; {
    dispatch({
      type: ACTIONS.UPDATE_QUANTITY,
      payload: { id, quantity }
    });
  };

  const clearCart = () =&gt; {
    dispatch({ type: ACTIONS.CLEAR_CART });
  };

  const total = state.items.reduce(
    (sum, item) =&gt; sum + item.price * item.quantity,
    0
  );

  return (
    &lt;div&gt;
      &lt;h2&gt;Carrito de Compras&lt;/h2&gt;
      &lt;ul&gt;
        {state.items.map(item =&gt; (
          &lt;li key={item.id}&gt;
            {item.name} - ${item.price} x {item.quantity}
            &lt;button onClick={() =&gt; updateQuantity(item.id, item.quantity + 1)}&gt;
              +
            &lt;/button&gt;
            &lt;button onClick={() =&gt; updateQuantity(item.id, item.quantity - 1)}&gt;
              -
            &lt;/button&gt;
            &lt;button onClick={() =&gt; removeItem(item.id)}&gt;
              Eliminar
            &lt;/button&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;p&gt;Total: ${total.toFixed(2)}&lt;/p&gt;
      &lt;button onClick={() =&gt; addItem({ id: 1, name: &#x27;Producto 1&#x27;, price: 10 })}&gt;
        Agregar Producto 1
      &lt;/button&gt;
      &lt;button onClick={clearCart}&gt;Limpiar Carrito&lt;/button&gt;
    &lt;/div&gt;
  );
};

export default ShoppingCart;</code></pre>

      <h4 id="mejores-practicas-usereducer">
        Mejores prácticas con useReducer
      </h4>
      <ul>
        <li>
          Usa constantes para los tipos de acción: Evita errores de tipeo y
          facilita el refactoring
        </li>
        <li>
          El reducer debe ser puro: No debe tener efectos secundarios ni
          mutaciones directas
        </li>
        <li>
          Retorna siempre un nuevo objeto: Usa el spread operator (...) para
          crear nuevos objetos en lugar de modificar el estado directamente
        </li>
        <li>
          Incluye un caso default: Siempre retorna el estado actual si la acción
          no coincide
        </li>
        <li>
          Usa payload para datos adicionales: Envía información adicional en la
          propiedad payload de la acción
        </li>
      </ul>

      <h2 id="fetch">Fetch</h2>
      <hr />
      <p>
        Fetch es la API nativa de JavaScript para realizar peticiones HTTP a
        servidores externos. En React, estas peticiones se realizan típicamente
        dentro de useEffect, ya que son efectos secundarios que deben ejecutarse
        después del renderizado inicial del componente.
      </p>
      <p>
        La combinación de useState para almacenar los datos y useEffect para
        obtenerlos es el patrón fundamental para trabajar con APIs en React.
      </p>

      <h3 id="ejemplo-basico-then">Ejemplo básico con .then()</h3>
      <p>Un llamado simple a una API se vería así:</p>
      <pre><code>import { useState, useEffect } from &#x27;react&#x27;;

const UserList = () =&gt; {
  // Estado para almacenar los usuarios
  const [users, setUsers] = useState([]);

  useEffect(() =&gt; {
    // Realizamos la petición HTTP
    fetch(&#x27;https://jsonplaceholder.typicode.com/users&#x27;)
      // Convertimos la respuesta a JSON
      .then(response =&gt; response.json())
      // Guardamos los datos en el estado
      .then(data =&gt; setUsers(data))
      // Manejamos errores básicos
      .catch(error =&gt; console.error(&#x27;Error fetching data:&#x27;, error));
  }, []); // Array vacío = solo se ejecuta al montar

  // Renderizamos la lista
  return (
    &lt;div&gt;
      &lt;h1&gt;Usuarios&lt;/h1&gt;
      &lt;ul&gt;
        {users.map(user =&gt; (
          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};

export default UserList;</code></pre>

      <h3 id="ejemplo-moderno-async-await">Ejemplo moderno con async/await</h3>
      <p>
        La sintaxis moderna con async/await es más legible y fácil de mantener.
        Sin embargo, como useEffect no puede ser directamente async, debemos
        crear una función interna:
      </p>
      <pre><code>import { useState, useEffect } from &#x27;react&#x27;;

const UserList = () =&gt; {
  const [users, setUsers] = useState([]);

  useEffect(() =&gt; {
    // Función async dentro de useEffect
    const fetchUsers = async () =&gt; {
      try {
        const response = await fetch(&#x27;https://jsonplaceholder.typicode.com/users&#x27;);
        const data = await response.json();
        setUsers(data);
      } catch (error) {
        console.error(&#x27;Error fetching data:&#x27;, error);
      }
    };

    // Ejecutamos la función
    fetchUsers();
  }, []);

  return (
    &lt;div&gt;
      &lt;h1&gt;Usuarios&lt;/h1&gt;
      &lt;ul&gt;
        {users.map(user =&gt; (
          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};</code></pre>

      <h3 id="cleanup-abort-controller">Cleanup con AbortController</h3>
      <p>
        Cuando un componente se desmonta mientras una petición está en curso,
        puede causar memory leaks o errores al intentar actualizar el estado.
        AbortController nos permite cancelar peticiones pendientes:
      </p>
      <pre><code>import { useState, useEffect } from &#x27;react&#x27;;

const UserList = () =&gt; {
  const [users, setUsers] = useState([]);

  useEffect(() =&gt; {
    // Creamos un controlador para abortar la petición
    const controller = new AbortController();

    const fetchUsers = async () =&gt; {
      try {
        const response = await fetch(&#x27;https://jsonplaceholder.typicode.com/users&#x27;, {
          signal: controller.signal // Conectamos el signal
        });
        const data = await response.json();
        setUsers(data);
      } catch (error) {
        // Ignoramos errores de abort
        if (error.name !== &#x27;AbortError&#x27;) {
          console.error(&#x27;Error fetching data:&#x27;, error);
        }
      }
    };

    fetchUsers();

    // Cleanup: cancelamos la petición si el componente se desmonta
    return () =&gt; controller.abort();
  }, []);

  return (
    &lt;div&gt;
      &lt;h1&gt;Usuarios&lt;/h1&gt;
      &lt;ul&gt;
        {users.map(user =&gt; (
          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};</code></pre>

      <p>
        <strong>Nota:</strong> Estos ejemplos básicos no incluyen estados de
        carga ni manejo de errores para el usuario. En la siguiente sección
        veremos cómo implementar una solución más completa y profesional.
      </p>

      <h3 id="manejo-de-errores-y-carga">Manejo de errores y carga</h3>
      <p>
        En aplicaciones reales, es crucial comunicar al usuario el estado de las
        peticiones HTTP. Para esto, utilizamos tres estados que trabajan en
        conjunto:
      </p>
      <ul>
        <li><strong>data</strong> (users): Los datos obtenidos de la API</li>
        <li>
          <strong>loading</strong> (isLoading): Indica si la petición está en
          curso
        </li>
        <li>
          <strong>error</strong>: Almacena cualquier error que ocurra durante la
          petición
        </li>
      </ul>
      <p>
        Estos tres estados forman el patrón estándar de manejo de peticiones
        asíncronas en React.
      </p>

      <h4>Implementación básica</h4>
      <pre><code>import { useState, useEffect } from &#x27;react&#x27;;

const UserList = () =&gt; {
  // Estado para los datos
  const [users, setUsers] = useState([]);
  // Estado para la carga
  const [isLoading, setIsLoading] = useState(true);
  // Estado para errores
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    const fetchUsers = async () =&gt; {
      try {
        const response = await fetch(&#x27;https://jsonplaceholder.typicode.com/users&#x27;);

        // Verificamos si la respuesta fue exitosa
        if (!response.ok) {
          throw new Error(`Error HTTP: ${response.status}`);
        }

        const data = await response.json();
        setUsers(data);
      } catch (error) {
        // Guardamos el mensaje de error
        setError(error.message);
      } finally {
        // Siempre desactivamos el loading
        setIsLoading(false);
      }
    };

    // IMPORTANTE: Ejecutamos la función
    fetchUsers();
  }, []);

  // Renderizado condicional: mostramos loading
  if (isLoading) {
    return &lt;p&gt;Cargando usuarios...&lt;/p&gt;;
  }

  // Renderizado condicional: mostramos error
  if (error) {
    return &lt;p&gt;Error: {error}&lt;/p&gt;;
  }

  // Renderizado normal: mostramos los datos
  return (
    &lt;div&gt;
      &lt;h1&gt;Usuarios&lt;/h1&gt;
      &lt;ul&gt;
        {users.map(user =&gt; (
          &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/div&gt;
  );
};

export default UserList;</code></pre>

      <h4>Implementación profesional con cleanup</h4>
      <p>
        Una implementación más robusta incluye AbortController para cancelar
        peticiones pendientes y evitar actualizaciones de estado en componentes
        desmontados:
      </p>
      <pre><code>import { useState, useEffect } from &#x27;react&#x27;;

const UserList = () =&gt; {
  const [users, setUsers] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() =&gt; {
    const controller = new AbortController();

    const fetchUsers = async () =&gt; {
      try {
        setIsLoading(true);
        setError(null);

        const response = await fetch(
          &#x27;https://jsonplaceholder.typicode.com/users&#x27;,
          { signal: controller.signal }
        );

        if (!response.ok) {
          throw new Error(`Error HTTP: ${response.status}`);
        }

        const data = await response.json();
        setUsers(data);
      } catch (error) {
        // Ignoramos errores de cancelación
        if (error.name !== &#x27;AbortError&#x27;) {
          setError(error.message);
        }
      } finally {
        setIsLoading(false);
      }
    };

    fetchUsers();

    // Cleanup: cancelamos la petición al desmontar
    return () =&gt; controller.abort();
  }, []);

  if (isLoading) {
    return (
      &lt;div&gt;
        &lt;h1&gt;Usuarios&lt;/h1&gt;
        &lt;p&gt;Cargando usuarios...&lt;/p&gt;
      &lt;/div&gt;
    );
  }

  if (error) {
    return (
      &lt;div&gt;
        &lt;h1&gt;Usuarios&lt;/h1&gt;
        &lt;p style={{ color: &#x27;red&#x27; }}&gt;Error: {error}&lt;/p&gt;
        &lt;button onClick={() =&gt; window.location.reload()}&gt;
          Reintentar
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }

  return (
    &lt;div&gt;
      &lt;h1&gt;Usuarios ({users.length})&lt;/h1&gt;
      {users.length === 0 ? (
        &lt;p&gt;No hay usuarios disponibles&lt;/p&gt;
      ) : (
        &lt;ul&gt;
          {users.map(user =&gt; (
            &lt;li key={user.id}&gt;{user.name}&lt;/li&gt;
          ))}
        &lt;/ul&gt;
      )}
    &lt;/div&gt;
  );
};

export default UserList;</code></pre>

      <h4>Patrón de estados y flujo</h4>
      <p>El flujo de estados sigue este patrón:</p>
      <ol>
        <li>
          <strong>Estado inicial:</strong> isLoading = true, error = null, data
          = []
        </li>
        <li>
          <strong>Durante la petición:</strong> isLoading permanece en true
        </li>
        <li>
          <strong>Si tiene éxito:</strong> isLoading = false, data se actualiza
        </li>
        <li>
          <strong>Si falla:</strong> isLoading = false, error contiene el
          mensaje
        </li>
      </ol>
      <p>
        <strong>Importante:</strong> El bloque <code>finally</code> garantiza
        que isLoading siempre se desactive, independientemente de si la petición
        fue exitosa o falló.
      </p>

      <h2 id="react-router">React Router</h2>
      <hr />
      <p>
        React Router es la biblioteca estándar para manejar navegación y rutas
        en aplicaciones React. Permite crear Single Page Applications (SPA) con
        navegación entre diferentes vistas sin recargar la página completa.
      </p>
      <p>
        A medida que una aplicación crece, se vuelve esencial implementar una
        estructura organizada que permita la navegación entre diferentes vistas.
        React Router transforma aplicaciones simples en sistemas complejos de
        múltiples páginas, mejorando tanto la navegabilidad como la
        mantenibilidad del código.
      </p>

      <h3 id="estructura-de-un-react-router">Estructura de un react router</h3>
      <p>
        La estructura básica de React Router se compone de varios elementos
        fundamentales que trabajan en conjunto:
      </p>
      <ul>
        <li>
          <strong>Router (Provider):</strong> El componente contenedor principal
          (BrowserRouter, HashRouter, etc.) que proporciona el contexto de
          navegación a toda la aplicación. Similar a React Context, permite que
          los componentes hijos accedan a la información de rutas.
        </li>
        <li>
          <strong>Routes:</strong> Contenedor que agrupa todas las rutas de la
          aplicación. Solo renderiza la primera ruta que coincida con la URL
          actual.
        </li>
        <li>
          <strong>Route:</strong> Define una ruta específica usando las props
          <code>path</code> (URL) y <code>element</code> (componente a
          renderizar).
        </li>
        <li>
          <strong>Link/NavLink:</strong> En lugar de etiquetas
          <code>&lt;a&gt;</code>, React Router usa estos componentes para crear
          enlaces que navegan sin recargar la página.
        </li>
        <li>
          <strong>Outlet:</strong> Placeholder para renderizar rutas anidadas
          dentro de un componente padre.
        </li>
      </ul>
      <p>
        Además, los Routers permiten incluir componentes persistentes como Menús
        o Footers que se mantienen visibles en todas las vistas, asegurando una
        estructura consistente en la aplicación.
      </p>

      <h3 id="tipos-de-routers">Tipos de routers</h3>
      <p>
        React Router DOM ofrece tres tipos principales de routers, cada uno con
        un propósito específico y una manera particular de gestionar la
        navegación:
      </p>

      <h4>BrowserRouter</h4>
      <p>
        El router estándar para aplicaciones web modernas. Utiliza la API de
        History del navegador para crear URLs limpias y legibles, como
        <code>/home</code>, <code>/blog</code> o <code>/contact</code>.
      </p>
      <p>
        <strong>Cuándo usarlo:</strong> En la mayoría de aplicaciones web
        desplegadas en servidores que pueden manejar rutas dinámicas (como
        Vercel, Netlify, o servidores con configuración SPA).
      </p>
      <pre><code>import { BrowserRouter, Routes, Route } from &#x27;react-router-dom&#x27;;

function App() {
  return (
    &lt;BrowserRouter&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;/about&quot; element={&lt;About /&gt;} /&gt;
        &lt;Route path=&quot;/contact&quot; element={&lt;Contact /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/BrowserRouter&gt;
  );
}

// URLs resultantes:
// https://example.com/
// https://example.com/about
// https://example.com/contact</code></pre>

      <h4>HashRouter</h4>
      <p>
        Utiliza el símbolo de hash (<code>#</code>) en la URL para simular
        diferentes rutas. Las URLs se ven como
        <code>example.com/#/about</code> o <code>example.com/#/blog</code>.
      </p>
      <p>
        <strong>Cuándo usarlo:</strong> En entornos donde no tienes control del
        servidor (páginas estáticas, GitHub Pages) o cuando necesitas
        compatibilidad con navegadores antiguos. El servidor solo ve la parte
        antes del <code>#</code>, por lo que no necesita configuración especial.
      </p>
      <pre><code>import { HashRouter, Routes, Route } from &#x27;react-router-dom&#x27;;

function App() {
  return (
    &lt;HashRouter&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;/about&quot; element={&lt;About /&gt;} /&gt;
        &lt;Route path=&quot;/contact&quot; element={&lt;Contact /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/HashRouter&gt;
  );
}

// URLs resultantes:
// https://example.com/#/
// https://example.com/#/about
// https://example.com/#/contact</code></pre>

      <h4>MemoryRouter</h4>
      <p>
        Mantiene el historial de navegación en memoria sin reflejarlo en la URL
        del navegador. La barra de direcciones no cambia al navegar entre rutas.
      </p>
      <p>
        <strong>Cuándo usarlo:</strong> En aplicaciones móviles (React Native),
        entornos de testing, o aplicaciones embebidas donde no se requiere
        sincronización con la URL del navegador.
      </p>
      <pre><code>import { MemoryRouter, Routes, Route } from &#x27;react-router-dom&#x27;;

function App() {
  return (
    &lt;MemoryRouter initialEntries={[&#x27;/&#x27;]} initialIndex={0}&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/&quot; element={&lt;Home /&gt;} /&gt;
        &lt;Route path=&quot;/about&quot; element={&lt;About /&gt;} /&gt;
        &lt;Route path=&quot;/contact&quot; element={&lt;Contact /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/MemoryRouter&gt;
  );
}

// La URL permanece igual: https://example.com/
// Pero internamente el router navega entre rutas</code></pre>

      <h4>Comparación</h4>
      <table>
        <thead>
          <tr>
            <th>Router</th>
            <th>URL</th>
            <th>Requiere configuración de servidor</th>
            <th>Uso principal</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><strong>BrowserRouter</strong></td>
            <td>/about</td>
            <td>Sí</td>
            <td>Aplicaciones web modernas</td>
          </tr>
          <tr>
            <td><strong>HashRouter</strong></td>
            <td>/#/about</td>
            <td>No</td>
            <td>Páginas estáticas, GitHub Pages</td>
          </tr>
          <tr>
            <td><strong>MemoryRouter</strong></td>
            <td>(no cambia)</td>
            <td>No aplica</td>
            <td>Testing, React Native</td>
          </tr>
        </tbody>
      </table>

      <h3 id="instalacion">Instalación</h3>
      <p>
        Para instalar React Router corremos el comando
        <code>pnpm install react-router-dom@latest</code>. Podemos asegurarnos
        que esté todo bien corriendo la aplicación con <code>npm run dev</code>.
      </p>

      <h3 id="rutas-estaticas-hashrouter">Rutas estáticas (HashRouter)</h3>
      <p>
        Podemos colocar rutas estáticas con hash dentro de nuestro documento
        usando el componente HashRouter de React Router. Para esto, dentro de
        nuestro archivo app.jsx colocamos:
      </p>
      <pre><code>import { HashRouter, Routes, Route } from 'react-router-dom';

function App() {
  return (
    &lt;&gt;
      &lt;HashRouter&gt;
        &lt;Menu /&gt;
        &lt;Routes&gt;
          &lt;Route path=&quot;/&quot; element={&lt;HomePage /&gt;} /&gt;
          &lt;Route path=&quot;/profile&quot; element={&lt;ProfilePage /&gt;} /&gt;
          &lt;Route path=&quot;/blog&quot; element={&lt;BlogPage /&gt;} /&gt;
          &lt;Route
            path=&quot;*&quot;
            element={&lt;h1 className=&quot;text-3xl font-bold&quot;&gt;Not Found&lt;/h1&gt;}
          /&gt;
        &lt;/Routes&gt;
      &lt;/HashRouter&gt;
    &lt;/&gt;
  );
}</code></pre>
      <p>
        Dentro de este componente tendremos las páginas/rutas que vamos a
        renderizar dentro del componente Routes, y cada ruta por separado va a
        usar el componente Route. Dicho componente va a tener un atributo path
        que es el hash que va a leer, como también va a tener el atributo
        element que hará referencia a lo que se va a renderizar.
      </p>

      <h3 id="navegacion-navlink">Navegación (NavLink)</h3>
      <p>
        Podemos usar el componente NavLink en vez de la etiqueta a para crear
        links. Este componente nos permite cambiar la URL de la app sin
        necesidad de recargar la página. Así tendremos algo como:
      </p>
      <pre><code>import { NavLink } from 'react-router-dom';

const routes = [
  { to: '/', text: 'Home' },
  { to: '/blog', text: 'Blog' },
  { to: '/profile', text: 'Profile' }
];

function Menu() {
  return (
    &lt;ul&gt;
      {routes.map(route =&gt; (
        &lt;li key={route.to}&gt;
          &lt;NavLink to={route.to} style={({ isActive }) =&gt; ({ color: isActive ? 'red' : 'blue' })}&gt;
            {route.text}
          &lt;/NavLink&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}

export default Menu;</code></pre>
      <p>
        Esto nos dará como resultado una lista ul con componentes NavLink
        relacionados a las rutas definidas en la constante routes. Además, si
        estamos ubicados sobre esa opción se va a colocar en rojo.
      </p>

      <h3 id="rutas-dinamicas-useparams">Rutas dinámicas (useParams)</h3>
      <p>
        El slug es una parte de la URL que actúa como un identificador único
        para las páginas o elementos de contenido en una aplicación,
        generalmente al final de la URL como
        platzi.com/clases/como-aprender-react.
      </p>
      <p>
        Gracias al slug podemos cambiar el contenido interno de un componente
        manteniendo la misma estructura. El slug permite al componente entender
        qué datos cargar y cómo consultar el backend para obtener información
        diferente para cada vista.
      </p>
      <p>
        Empezamos creando una lista de publicaciones para un blog. El componente
        base será similar para cada entrada de blog, cambiando solo su contenido
        dependiendo del slug. Este componente se llamará BlogPost y hará uso del
        React hook useParams para este objetivo. Veamos cómo se hace.
      </p>
      <p>
        Primero, creamos un archivo separado para los datos del blog
        (blogData.js) y los exportamos para que puedan ser usados por otros
        componentes:
      </p>
      <pre><code>// blogData.js
export const blogData = [
  {
    title: "¿Qué es React?",
    slug: "que-es-react",
    content: "React es el mejor framework de JavaScript.",
    author: "Juan de Sen"
  },
  {
    title: "¿Qué es Vue?",
    slug: "que-es-vue",
    content: "Vue es un framework progresivo.",
    author: "Otro autor"
  }
];</code></pre>
      <p>
        Después creamos el componente BlogPage que va a mostrar una lista con
        los distintos posts para leer. Importamos los datos desde blogData.js y
        en la prop <code>to</code> del componente Link es donde vamos a colocar
        la parte dinámica:
      </p>
      <pre><code>// BlogPage.jsx
import { Link } from 'react-router-dom';
import { blogData } from './blogData';

const BlogPage = () => {
  return (
    &lt;ul&gt;
      {blogData.map(post =&gt; (
        &lt;li key={post.slug}&gt;
          &lt;Link to={`/blog/${post.slug}`}&gt;{post.title}&lt;/Link&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
};

export default BlogPage;</code></pre>
      <p>
        Después en nuestro archivo app.jsx definimos qué se va a renderizar
        cuando entremos a esa ruta dinámica. En este caso vamos a renderizar un
        componente llamado BlogPost:
      </p>
      <pre><code>// App.jsx
import { HashRouter, Routes, Route } from 'react-router-dom';
import BlogPage from './BlogPage';
import BlogPost from './BlogPost';

function App() {
  return (
    &lt;HashRouter&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/blog&quot; element={&lt;BlogPage /&gt;} /&gt;
        &lt;Route path=&quot;/blog/:slug&quot; element={&lt;BlogPost /&gt;} /&gt;
      &lt;/Routes&gt;
    &lt;/HashRouter&gt;
  );
}

export default App;</code></pre>
      <p>
        Por último, creamos el componente BlogPost que va a tener la estructura
        de los blogs pero cuya información va a variar dependiendo del post.
        Importamos blogData y useParams, y agregamos un manejo de error por si
        el slug no existe:
      </p>
      <pre><code>// BlogPost.jsx
import { useParams } from 'react-router-dom';
import { blogData } from './blogData';

const BlogPost = () => {
  const { slug } = useParams(); // Obtiene el slug desde la URL

  // Lógica para obtener el post correcto basado en el slug
  const post = blogData.find(post =&gt; post.slug === slug);

  // Manejo de error si no se encuentra el post
  if (!post) {
    return &lt;h2&gt;Post no encontrado&lt;/h2&gt;;
  }

  return (
    &lt;div&gt;
      &lt;h2&gt;{post.title}&lt;/h2&gt;
      &lt;p&gt;{post.content}&lt;/p&gt;
      &lt;p&gt;{post.author}&lt;/p&gt;
    &lt;/div&gt;
  );
};

export default BlogPost;</code></pre>

      <h3 id="rutas-anidadas-outlet">Rutas anidadas (Outlet)</h3>
      <p>
        Las Nested Routes (rutas anidadas), como su nombre lo indica, son rutas
        anidadas dentro de otras. Esto permite tener una ruta principal que
        mantiene su contenido visible mientras se navega por subrutas. Por
        ejemplo, una página de blog que mantiene su título y menú mientras
        muestra diferentes posts.
      </p>
      <p>
        El componente <code>Outlet</code> actúa como un marcador de posición
        donde se renderizarán las rutas hijas anidadas.
      </p>
      <p>
        Dentro del archivo app.jsx vamos a encapsular las rutas dinámicas de los
        posts dentro de la ruta de BlogPage:
      </p>
      <pre><code>// App.jsx
import { HashRouter, Routes, Route } from 'react-router-dom';
import BlogPage from './BlogPage';
import BlogPost from './BlogPost';

function App() {
  return (
    &lt;HashRouter&gt;
      &lt;Routes&gt;
        &lt;Route path=&quot;/blog&quot; element={&lt;BlogPage /&gt;}&gt;
          &lt;Route path=&quot;:slug&quot; element={&lt;BlogPost /&gt;} /&gt;
        &lt;/Route&gt;
      &lt;/Routes&gt;
    &lt;/HashRouter&gt;
  );
}

export default App;</code></pre>
      <p>
        Después dentro del componente BlogPage.jsx agregamos el componente
        Outlet, que es donde se renderizarán las rutas hijas:
      </p>
      <pre><code>// BlogPage.jsx
import { Link, Outlet } from 'react-router-dom';
import { blogData } from './blogData';

function BlogPage() {
  return (
    &lt;div&gt;
      &lt;h1&gt;Blog&lt;/h1&gt;
      &lt;ul&gt;
        {blogData.map(post =&gt; (
          &lt;li key={post.slug}&gt;
            &lt;Link to={`/blog/${post.slug}`}&gt;{post.title}&lt;/Link&gt;
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
      &lt;Outlet /&gt;
    &lt;/div&gt;
  );
}

export default BlogPage;</code></pre>
      <p>
        Al hacer esto, cuando navegas a una ruta secundaria como
        <code>/blog/que-es-react</code>, el contenido del BlogPost se renderiza
        en el lugar donde está ubicado el Outlet, manteniendo visible el título
        "Blog" y la lista de posts.
      </p>

      <h2 id="autenticacion">Autenticacion</h2>
      <p>
        Vamos a crear un sistema de autenticación ficticio para ilustrar cómo se
        podría implementar un flujo de autenticación.
      </p>
      <p>
        Primero creamos las paginas de login y logout que queremos crear, para
        la pagina del Login tendremos
      </p>
      <pre><code >import { useState } from &quot;react&quot;;
import { useAuth } from &quot;../auth/auth.jsx&quot;;</code></pre>
      <pre><code >export default function LoginPage() {
  const auth = useAuth();</code></pre>
      <pre><code >  const [username, setUsername] = useState(&quot;&quot;);</code></pre>
      <pre><code >  function login(event) {</code></pre>
      <p>event.preventDefault();</p>
      <pre><code >    auth.login({ username });
  }</code></pre>
      <pre><code >  return (
    &lt;&gt;
      &lt;h1 className=&quot;text-3xl font-bold&quot;&gt;Login&lt;/h1&gt;</code></pre>
      <pre><code >      &lt;form onSubmit={login} className=&quot;flex flex-col gap-1.5&quot;&gt;
        &lt;label htmlFor=&quot;username&quot;&gt;Escribe tu nombre de usuario&lt;/label&gt;
        &lt;input</code></pre>
      <ul>
        <li>type=&quot;text&quot;</li>
        <li>id=&quot;username&quot;</li>
      </ul>
      <pre><code >          value={username}
          onChange={(e) =&gt; setUsername(e.target.value)}
          className=&quot;bg-gray-200 rounded-md&quot;
        /&gt;
        &lt;button type=&quot;submit&quot;&gt;Enviar&lt;/button&gt;
      &lt;/form&gt;
    &lt;/&gt;
  );
}</code></pre>
      <p>Para la pagina del logout tendremos</p>
      <pre><code >import { useState } from &quot;react&quot;;
import { useAuth } from &quot;../auth/auth.jsx&quot;;</code></pre>
      <pre><code >export default function LoginPage() {
  const auth = useAuth();</code></pre>
      <pre><code >  const [username, setUsername] = useState(&quot;&quot;);</code></pre>
      <pre><code >  function login(event) {</code></pre>
      <p>event.preventDefault();</p>
      <pre><code >    auth.login({ username });
  }</code></pre>
      <pre><code >  return (
    &lt;&gt;
      &lt;h1 className=&quot;text-3xl font-bold&quot;&gt;Login&lt;/h1&gt;</code></pre>
      <pre><code >      &lt;form onSubmit={login} className=&quot;flex flex-col gap-1.5&quot;&gt;
        &lt;label htmlFor=&quot;username&quot;&gt;Escribe tu nombre de usuario&lt;/label&gt;
        &lt;input</code></pre>
      <ul>
        <li>type=&quot;text&quot;</li>
        <li>id=&quot;username&quot;</li>
      </ul>
      <pre><code >          value={username}
          onChange={(e) =&gt; setUsername(e.target.value)}
          className=&quot;bg-gray-200 rounded-md&quot;
        /&gt;
        &lt;button type=&quot;submit&quot;&gt;Enviar&lt;/button&gt;
      &lt;/form&gt;
    &lt;/&gt;
  );
}
Tenemos que añadir estas paginas en el HashRouter
&lt;Route path=&quot;/login&quot; element={&lt;LoginPage /&gt;} /&gt;
&lt;Route path=&quot;/logout&quot; element={&lt;LogoutPage /&gt;} /&gt;
&lt;Route path=&quot;/profile&quot; element={&lt;ProfilePage /&gt;} /&gt;</code></pre>
      <p>Como tambien agregarlas al menu</p>
      <pre><code >const routes = [
  { to: &quot;/&quot;, text: &quot;Home&quot; },
  { to: &quot;/profile&quot;, text: &quot;Profile&quot; },
  { to: &quot;/blog&quot;, text: &quot;Blog&quot; },
  { to: &quot;/login&quot;, text: &quot;Login&quot; },
  { to: &quot;/logout&quot;, text: &quot;Logout&quot; },</code></pre>
      <p>];</p>
      <p>
        Después, vamos a querer usar metodos y estados en toda la aplicación,
        por lo que vamos a necesitar un archivo de autenticacion que use un
        reactContext y envie estos valores a traves de un provider. Empezemos
        diciendole a la aplicación que va a usar valores del provider,
        modificamos nuestro archivo app.jsx
      </p>
      <pre><code >&lt;HashRouter&gt;
   &lt;AuthProvider&gt;
      &lt;Menu /&gt;</code></pre>
      <pre><code >      &lt;Routes&gt;
        &lt;Route path=&quot;/&quot; element={&lt;HomePage /&gt;} /&gt;</code></pre>
      <ul>
        <li>…</li>
        <li>…</li>
      </ul>
      <pre><code >      &lt;/Routes&gt;
   &lt;/AuthProvider&gt;
&lt;/HashRouter&gt;</code></pre>
      <p>
        Ahora tenemos que crear nuestro archivo auth.jsx que es donde vamos a
        crear el contexto y los valores que va a enviar el provider
      </p>
      <pre><code >import React from &quot;react&quot;;
import { useNavigate } from &quot;react-router-dom&quot;;</code></pre>
      <p>// context</p>
      <pre><code >const AuthContext = React.createContext();</code></pre>
      <p>// provider</p>
      <pre><code >function AuthProvider({ children }) {</code></pre>
      <p>// navigation</p>
      <pre><code >  const navigate = useNavigate();</code></pre>
      <p>// state</p>
      <pre><code >  const [user, setUser] = React.useState(null);</code></pre>
      <p>// methods</p>
      <pre><code >  const login = ({ username }) =&gt; {
    setUser({ username });</code></pre>
      <p>navigate(&quot;/profile&quot;);</p>
      <pre><code >  };
  const logout = () =&gt; {</code></pre>
      <p>setUser(null);</p>
      <p>navigate(&quot;/&quot;);</p>
      <pre><code >  };</code></pre>
      <p>// values</p>
      <pre><code >  const auth = { user, login, logout };</code></pre>
      <p>// send values to provider</p>
      <pre><code >  return &lt;AuthContext.Provider value={auth}&gt;{children}&lt;/AuthContext.Provider&gt;;
}</code></pre>
      <p>// hook</p>
      <pre><code >function useAuth() {
  const auth = React.useContext(AuthContext);
  return auth;
}</code></pre>
      <pre><code >export { useAuth, AuthProvider };</code></pre>
      <h3 id="proteger-rutas-con-autenticacion">
        proteger rutas con autenticacion
      </h3>
      <p>
        primero tenemos que definir que rutas seran publicas y cuales seran
        privadas, para esto vamos a crear una tercera propiedad de las rutas
      </p>
      <pre><code >const routes = [
  { to: &quot;/&quot;, text: &quot;Home&quot;, private: false },
  { to: &quot;/profile&quot;, text: &quot;Profile&quot;, private: true },
  { to: &quot;/blog&quot;, text: &quot;Blog&quot;, private: false },
  { to: &quot;/login&quot;, text: &quot;Login&quot;, private: false },
  { to: &quot;/logout&quot;, text: &quot;Logout&quot;, private: true },</code></pre>
      <p>];</p>
      <p>
        Después en nuestro menus donde renderizamos las rutas vamos a usar un
        condicional, tal que si existe un usuario vamos a mostrar la ruta
      </p>
      <pre><code >export default function Menu() {
  const auth = useAuth();</code></pre>
      <pre><code >  return (
    &lt;nav&gt;
      &lt;ul className=&quot;flex flex-row gap-4&quot;&gt;
        {routes.map((route) =&gt; {
          if (route.private &amp;&amp; !auth.user) return null;
          if(route.to == &#x27;/login&#x27; &amp;&amp; auth.user){
            return null
          }</code></pre>
      <pre><code >          return (
            &lt;li key={route.text}&gt;
              &lt;NavLink
                style={({ isActive }) =&gt; ({</code></pre>
      <p>color: isActive ? &quot;red&quot; : &quot;blue&quot;,</p>
      <pre><code >                })}
                to={route.to}</code></pre>
      <p>&gt;</p>
      <pre><code >                {route.text}
              &lt;/NavLink&gt;
            &lt;/li&gt;
          );
        })}
      &lt;/ul&gt;
    &lt;/nav&gt;
  );
}</code></pre>
      <h3 id="proteccion-de-rutas-con-redireccionamiento">
        Proteccion de rutas con redireccionamiento
      </h3>
      <p>
        Cuando desarrollamos aplicaciones web, uno de los aspectos más cruciales
        es proteger adecuadamente las rutas. Podemos ocultar rutas del menú,
        pero todavía pueden ser accesibles a través de la URL directa. Siguiendo
        las mejores prácticas de React, es vital garantizar que los usuarios no
        autenticados no puedan acceder a ciertas páginas y que los usuarios
        autenticados no sean redirigidos a páginas de acceso.
      </p>
      <p>
        Implementar rutas protegidas implica involucrar un componente que
        gestione las redirecciones según el estado de autenticación del usuario.
        Crear un componente reutilizable es la mejor estrategia para evitar la
        repetición de código.
      </p>
      <p>Dentro de nuestro archivo auth.jsx vamos a crear el componente</p>
      <pre><code >const AuthRoute = ({ children }) =&gt; {
  const auth = useAuth();</code></pre>
      <pre><code >  if (!auth.user) {
    return &lt;Navigate to=&quot;/login&quot; /&gt;;
  }</code></pre>
      <pre><code >  return children;
};</code></pre>
      <p>
        Después, en nuestro archivo app.jsx protegemos las rutas privadas dentro
        usando el componente
      </p>
      <pre><code >&lt;Route</code></pre>
      <p>path=&quot;/logout&quot;</p>
      <pre><code >        element={
        &lt;AuthRoute&gt;
          &lt;LogoutPage /&gt;
        &lt;/AuthRoute&gt;
        }
/&gt;
&lt;Route</code></pre>
      <p>path=&quot;/profile&quot;</p>
      <pre><code >        element={
        &lt;AuthRoute&gt;
         &lt;ProfilePage /&gt;
        &lt;/AuthRoute&gt;
         }
 /&gt;</code></pre>
      <p>
        Por ultimo, si ya iniciamos sesion no deberiamos poder ir denuevo a la
        pagina de login, por lo que en el archivo LoginPage agregamos
      </p>
      <pre><code >if (auth.user) {
    return &lt;p&gt;Ya has iniciado sesion como {auth.user.username}&lt;/p&gt;;
  }</code></pre>
      <p>
        Para que nos regrese ese mensaje y no el formulario para hacer login.
      </p>
      <h3 id="roles-y-autorizacion">Roles y autorizacion</h3>
      <p>Empezamos creando una lista de administradores</p>
      <pre><code >export const adminList = [&quot;admin1&quot;, &quot;admin2&quot;, &quot;admin3&quot;];</code></pre>
      <p>
        y cuando hacemos login, ya no solo mandamos el username, sino que
        tambien verificamos si es admin o no
      </p>
      <pre><code >const login = ({ username }) =&gt; {
    const isAdmin = adminList.includes(username);
    setUser({ username, isAdmin });</code></pre>
      <p>navigate(&quot;/profile&quot;);</p>
      <pre><code >  };</code></pre>
      <p>
        Ahora podemos agregar una funcionalidad para los admins, como eliminar
        un blog, para esto en nuestro archivo BlogPost.jsx agregamos
      </p>
      <pre><code >export default function BlogPost() {
  const auth = useAuth();
  const { slug } = useParams();
  const post = blogData.find((post) =&gt; post.slug === slug);</code></pre>
      <pre><code >  return (
    &lt;div&gt;
      &lt;h2&gt;{post.title}&lt;/h2&gt;
      &lt;p&gt;{post.content}&lt;/p&gt;
      &lt;p&gt;{post.author}&lt;/p&gt;
      {auth.user?.isAdmin &amp;&amp; &lt;button&gt;Eliminar Post&lt;/button&gt;}
    &lt;/div&gt;
  );
}</code></pre>
    </main>
  </body>
</html>
